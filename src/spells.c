/* * spells.c: code for player and creature spells, breaths, wands, scrolls, * etc.  * * Copyright (c) 1989 James E. Wilson, Robert A. Koeneke  * * This software may be copied and distributed for educational, research, and * not for profit purposes provided that this copyright and statement are * included in all such copies.  */#include "angband.h"#include "monster.h"#ifdef USG#ifndef ATARIST_MWC#include <string.h>#endif#else#ifndef VMS#include <strings.h>#endif#endif/* Lets do all prototypes correctly.... -CWS */#ifndef NO_LINT_ARGS#ifdef __STDC__char bolt_char(int, int, int, int);static void ball_destroy(int, int (**) (inven_type*));static void pause_if_screen_full(int *, int);void spell_hit_monster(monster_type *, int, int *, int, int *, int *, int);static void replace_spot(int, int, int);char inven_letter(inven_type *);#elsechar bolt_char();static void ball_destroy();static void pause_if_screen_full();void spell_hit_monster();static void replace_spot();char inven_letter();#endif#endif/* Following are spell procedure/functions			-RAK-	 *//* These routines are commonly used in the scroll, potion, wands, and	 *//* staves routines, and are occasionally called from other areas.	  *//* Now included are creature spells also.		       -RAK    */int8u spell_color(int type);int8u spell_color(int type){	switch(type)	  {	  	case GF_MAGIC_MISSILE:	  		return(randint(14));		/* multihued */	  	case GF_LIGHTNING:	  		return(MAC_YELLOW);	  	case GF_POISON_GAS:	  		return(MAC_GREEN);	  	case GF_ACID:	  		return(MAC_GRAY);	  	case GF_FROST:	  		return(MAC_LIGHTBLUE);	  	case GF_FIRE:	  		return(MAC_RED);	  	case GF_HOLY_ORB:	  		return(MAC_DARKGRAY);	  	case GF_ARROW:	  		return(MAC_LIGHTBROWN);	  	case GF_PLASMA:	  		return(MAC_RED);	  	case GF_NETHER:	  		return(MAC_PURPLE);	  	case GF_WATER:	  		return(MAC_BLUE);	  	case GF_CHAOS:	  		return(randint(14));		/* multihued */	  	case GF_SHARDS:	  		return(MAC_LIGHTBROWN);	  	case GF_SOUND:	  		return(MAC_ORANGE);	  	case GF_CONFUSION:	  		return(randint(14));		/* multihued */	  	case GF_DISENCHANT:	  		return(MAC_PURPLE);	  	case GF_NEXUS:	  		return(MAC_PINK);	  	case GF_FORCE:	  		return(MAC_WHITE);	  	case GF_INERTIA:	  		return(MAC_LIGHTGRAY);	  	case GF_LIGHT:	  		return(MAC_YELLOW);	  	case GF_DARK:	  		return(MAC_DARKGRAY);	  	case GF_TIME:	  		return(MAC_LIGHTBLUE);	  	case GF_GRAVITY:	  		return(MAC_GRAY);	  	case GF_MANA:	  		return(MAC_PINK);	  	case GF_METEOR:	  		return(MAC_ORANGE);	  	case GF_ICE:	  		return(MAC_LIGHTBLUE);	  	default:	  		return(MAC_BLACK);	  }}/* this assumes only 1 move apart -CFT */charbolt_char(y, x, ny, nx)int y, x, ny, nx;{    if (ny == y) return '-';    if (nx == x) return '|';    if ((ny-y) == (nx-x)) return '\\';    return '/';}/* return the appropriate item destroy test to the typ.  All that's left of * get_flags().  -CFT  *//* * add new destroys?  maybe GF_FORCE destroy potions, GF_PLASMA as lightning, * GF_SHARDS and GF_ICE maybe break things (potions?), and GF_METEOR breaks * potions and burns scrolls?  not yet, but it's an idea... -CFT  */static void ball_destroy(typ, destroy)int typ;int (**destroy) (inven_type*);{    switch (typ) {      case GF_FIRE:	*destroy = set_fire_destroy;	break;      case GF_ACID:	*destroy = set_acid_destroy;	break;      case GF_FROST:      case GF_SHARDS:      case GF_ICE:      case GF_FORCE:      case GF_SOUND:	*destroy = set_frost_destroy;	/* just potions and flasks -DGK */	break;      case GF_LIGHTNING:	*destroy = set_lightning_destroy;	break;      case GF_PLASMA:		   /* DGK */	*destroy = set_plasma_destroy;	/* fire+lightning -DGK */	break;      case GF_METEOR:		   /* DGK */	*destroy = set_meteor_destroy;	/* fire+shards -DGK */	break;      case GF_MANA:		   /* DGK */	*destroy = set_mana_destroy;	/* everything -DGK */	break;      case GF_HOLY_ORB:	   /* DGK */	*destroy = set_holy_destroy;	/* cursed stuff -DGK */	break;      case GF_MAGIC_MISSILE:      case GF_POISON_GAS:      case GF_ARROW:      case GF_NETHER:      case GF_WATER:      case GF_CHAOS:      case GF_CONFUSION:      case GF_DISENCHANT:      case GF_NEXUS:      case GF_INERTIA:      case GF_LIGHT:      case GF_DARK:      case GF_TIME:      case GF_GRAVITY:	*destroy = set_null;	break;      default:	msg_print("Unknown typ in ball_destroy().  This may mean trouble.");	*destroy = set_null;	break;    }}void monster_name(m_name, m_ptr, r_ptr)char               *m_name;monster_type       *m_ptr;creature_type      *r_ptr;{    if (!m_ptr->ml)	(void)strcpy(m_name, "It");    else {	if (r_ptr->cdefense & UNIQUE)	    (void)sprintf(m_name, "%s", r_ptr->name);	else	    (void)sprintf(m_name, "The %s", r_ptr->name);    }}void lower_monster_name(m_name, m_ptr, r_ptr)char               *m_name;monster_type       *m_ptr;creature_type      *r_ptr;{    if (!m_ptr->ml)	(void)strcpy(m_name, "it");    else {	if (r_ptr->cdefense & UNIQUE)	    (void)sprintf(m_name, "%s", r_ptr->name);	else	    (void)sprintf(m_name, "the %s", r_ptr->name);    }}/* teleport you a level (or three:-) */void tele_level(){    if (dun_level == Q_PLANE)	dun_level = 0;    else if (is_quest(dun_level))	dun_level -= 1;    else	dun_level += (-3) + 2 * randint(2);    if (dun_level < 0)	dun_level = 0;    new_level_flag = TRUE;}/* Sleep creatures adjacent to player			-RAK-	 */int sleep_monsters1(y, x)int y, x;{    register int            i, j;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    int                     sleep;    vtype                   out_val, m_name;    sleep = FALSE;    for (i = y - 1; i <= y + 1; i++)	for (j = x - 1; j <= x + 1; j++) {	    c_ptr = &cave[i][j];	    if (c_ptr->cptr > 1) {		m_ptr = &m_list[c_ptr->cptr];		r_ptr = &c_list[m_ptr->mptr];		monster_name(m_name, m_ptr, r_ptr);		if ((r_ptr->level >		     randint((py.misc.lev - 10) < 1 ? 1 : (py.misc.lev - 10)) + 10) ||		    (CHARM_SLEEP & r_ptr->cdefense) || (r_ptr->cdefense & UNIQUE)) {		    if (m_ptr->ml && (r_ptr->cdefense & CHARM_SLEEP))			c_recall[m_ptr->mptr].r_cdefense |= CHARM_SLEEP;		    (void)sprintf(out_val, "%s is unaffected.", m_name);		    msg_print(out_val);		} else {		    sleep = TRUE;		    m_ptr->csleep = 500;		    (void)sprintf(out_val, "%s falls asleep.", m_name);		    msg_print(out_val);		}	    }	}    return (sleep);}int lose_all_info(){    int                 i;    for (i = 0; i <= INVEN_AUX; i++) {	if (inventory[i].tval != TV_NOTHING)	    inventory[i].ident &= ~(ID_KNOWN2);    }    wizard_light(-1);    changeinven();    return (0);}void identify_pack(){    int                 i;    inven_type         *i_ptr;    for (i = 0; i <= INVEN_AUX; i++) {	if (inventory[i].tval != TV_NOTHING)	    identify(&i);	i_ptr = &inventory[i];	known2(i_ptr);    }    changeinven();}/* Detect any treasure on the current panel		-RAK-	 */int detect_treasure(){    register int        i, j, detect;    register cave_type *c_ptr;    detect = FALSE;    for (i = panel_row_min; i <= panel_row_max; i++)	for (j = panel_col_min; j <= panel_col_max; j++) {	    c_ptr = &cave[i][j];	    if ((c_ptr->tptr != 0) && (t_list[c_ptr->tptr].tval == TV_GOLD) &&		!test_light(i, j)) {		c_ptr->fm = TRUE;		lite_spot(i, j);		detect = TRUE;	    }	}    return (detect);}/* This will light up all spaces with "magic" items, including potions, * scrolls, rods, wands, staves, amulets, rings, and "enchanted" items. This * excludes all foods and spell books. -- JND   */int detect_magic(void);int detect_magic(){    register int         i, j, detect;    register cave_type  *c_ptr;    register inven_type *t_ptr;    int                  Tval;    detect = FALSE;    for (i = panel_row_min; i <= panel_row_max; i++)	for (j = panel_col_min; j <= panel_col_max; j++) {	    c_ptr = &cave[i][j];	    if ((c_ptr->tptr != 0) && (t_list[c_ptr->tptr].tval < TV_MAX_OBJECT)		&& !test_light(i, j)) {		t_ptr = &t_list[c_ptr->tptr];		Tval = t_ptr->tval;		    /* Is it a weapon or armor or light? */		if (((Tval > 9) && (Tval < 39)) &&		    (((t_ptr->tohit > 0) || (t_ptr->todam) || (t_ptr->toac)	    /* If so, check for plusses on weapons and armor ... */		      || (t_ptr->flags2 & TR_ARTIFACT))	    /* ... and check whether it is an artifact! ;)  */		     || ((Tval > 39) && (Tval < 77)))){	/* Is it otherwise magical? */		    c_ptr->fm = TRUE;		    lite_spot(i, j);		    detect = TRUE;		}	    }	}    return (detect);}int detect_enchantment(void);int detect_enchantment(){    register int i, j, detect, tv;    register cave_type *c_ptr;        detect = FALSE;    for (i = panel_row_min; i <= panel_row_max; i++)	for (j = panel_col_min; j <= panel_col_max; j++) {	    c_ptr = &cave[i][j];	    tv = t_list[c_ptr->tptr].tval;	    if ((c_ptr->tptr != 0) && !test_light(i, j) &&		( ((tv > TV_MAX_ENCHANT) && (tv < TV_FLASK)) || /* misc items */		 (tv == TV_MAGIC_BOOK) || (tv == TV_PRAYER_BOOK) || /* books */		 ((tv >= TV_MIN_WEAR) && (tv <= TV_MAX_ENCHANT) && /* armor/weap */		  ((t_list[c_ptr->tptr].flags2 & TR_ARTIFACT) || /* if Art., or */		   (t_list[c_ptr->tptr].tohit>0) || /* has pluses, then show */		   (t_list[c_ptr->tptr].todam>0) ||		   (t_list[c_ptr->tptr].toac>0))) )){		c_ptr->fm = TRUE;		lite_spot(i, j);		detect = TRUE;	    }	}    return(detect);}int detection(){    register int           i, detect;    register monster_type *m_ptr;    detect_treasure();    detect_object();    detect_trap();    detect_sdoor();    detect = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	if (panel_contains((int)m_ptr->fy, (int)m_ptr->fx)) {	    m_ptr->ml = TRUE;	/* works correctly even if hallucinating */	    c_print(CC(c_list[m_ptr->mptr].color,(char)c_list[m_ptr->mptr].cchar), (int)m_ptr->fy,		  (int)m_ptr->fx);	    detect = TRUE;	}    }    if (detect) {	msg_print("You sense the presence of monsters!");	msg_print(NULL);    /* must unlight every monster just lighted */	creatures(FALSE);    }    return (detect);}/* Detect all objects on the current panel		-RAK-	 */int detect_object(){    register int        i, j, detect;    register cave_type *c_ptr;    detect = FALSE;    for (i = panel_row_min; i <= panel_row_max; i++)	for (j = panel_col_min; j <= panel_col_max; j++) {	    c_ptr = &cave[i][j];	    if ((c_ptr->tptr != 0) && (t_list[c_ptr->tptr].tval < TV_MAX_OBJECT)		&& !test_light(i, j)) {		c_ptr->fm = TRUE;		lite_spot(i, j);		detect = TRUE;	    }	}    return (detect);}/* Locates and displays traps on current panel		-RAK-	 */int detect_trap(){    register int         i, j;    int                  detect;    register cave_type  *c_ptr;    register inven_type *t_ptr;    detect = FALSE;    for (i = panel_row_min; i <= panel_row_max; i++)	for (j = panel_col_min; j <= panel_col_max; j++) {	    c_ptr = &cave[i][j];	    if (c_ptr->tptr != 0)		if (t_list[c_ptr->tptr].tval == TV_INVIS_TRAP) {		    c_ptr->fm = TRUE;		    change_trap(i, j);		    detect = TRUE;		} else if (t_list[c_ptr->tptr].tval == TV_CHEST) {		    t_ptr = &t_list[c_ptr->tptr];		    known2(t_ptr);		}	}    return (detect);}void stair_creation(){    register cave_type *c_ptr;    register int        cur_pos;    c_ptr = &cave[char_row][char_col];    if ((c_ptr->tptr == 0) ||        ((t_list[c_ptr->tptr].tval != TV_UP_STAIR)  /* if not stairs or a store */         && (t_list[c_ptr->tptr].tval != TV_DOWN_STAIR)         && (t_list[c_ptr->tptr].tval != TV_STORE_DOOR)         && ((t_list[c_ptr->tptr].tval < TV_MIN_WEAR) ||             (t_list[c_ptr->tptr].tval > TV_MAX_WEAR) ||             !(t_list[c_ptr->tptr].flags2 & TR_ARTIFACT)))) {/* if no artifact here -CFT */	if (c_ptr->tptr != 0)	    (void)delete_object(char_row, char_col);	cur_pos = popt();	c_ptr->tptr = cur_pos;	if ((randint(2) == 1 || is_quest(dun_level)) && (dun_level > 0))	    invcopy(&t_list[cur_pos], OBJ_UP_STAIR);	else	    invcopy(&t_list[cur_pos], OBJ_DOWN_STAIR);    } else	msg_print("The object resists the spell.");}/* Surround the player with doors.			-RAK-	 */int door_creation(){    register int        i, j, door;    int                 k;    register cave_type *c_ptr;    door = FALSE;    for (i = char_row - 1; i <= char_row + 1; i++)	for (j = char_col - 1; j <= char_col + 1; j++)	    if ((i != char_row) || (j != char_col)) {		c_ptr = &cave[i][j];		if (c_ptr->fval <= MAX_CAVE_FLOOR) {		    if ((c_ptr->tptr == 0) ||			(	/* if not stairs or a store */			 (t_list[c_ptr->tptr].tval != TV_UP_STAIR) &&			 (t_list[c_ptr->tptr].tval != TV_DOWN_STAIR) &&			 (t_list[c_ptr->tptr].tval != TV_STORE_DOOR) &&			/* and if no artifact here -CFT */			/* note that all artifacts are wearable - dbd */             ((t_list[c_ptr->tptr].tval < TV_MIN_WEAR) ||			  (t_list[c_ptr->tptr].tval > TV_MAX_WEAR) || 			  !(t_list[c_ptr->tptr].flags2 & TR_ARTIFACT)) ))                    {			door = TRUE;			if (c_ptr->tptr != 0)			    (void)delete_object(i, j);			k = popt();			c_ptr->fval = BLOCKED_FLOOR;			c_ptr->tptr = k;			invcopy(&t_list[k], OBJ_CLOSED_DOOR);			lite_spot(i, j);		    } else			msg_print("The object resists the spell.");		}	    }    return (door);}/* Locates and displays all secret doors on current panel -RAK-	 */int detect_sdoor(){    register int        i, j, detect;    register cave_type *c_ptr;    detect = FALSE;    for (i = panel_row_min; i <= panel_row_max; i++)	for (j = panel_col_min; j <= panel_col_max; j++) {	    c_ptr = &cave[i][j];	    if (c_ptr->tptr != 0)	    /* Secret doors  */		if (t_list[c_ptr->tptr].tval == TV_SECRET_DOOR) {		    c_ptr->fm = TRUE;		    change_trap(i, j);		    detect = TRUE;		}	/* Staircases	 */		else if (((t_list[c_ptr->tptr].tval == TV_UP_STAIR) ||			  (t_list[c_ptr->tptr].tval == TV_DOWN_STAIR)) &&			 !c_ptr->fm) {		    c_ptr->fm = TRUE;		    lite_spot(i, j);		    detect = TRUE;		}	}    return (detect);}/* Locates and displays all invisible creatures on current panel -RAK- */int detect_invisible(){    register int           i, flag;    register monster_type *m_ptr;    flag = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	if (panel_contains((int)m_ptr->fy, (int)m_ptr->fx) &&	    (CM_INVISIBLE & c_list[m_ptr->mptr].cmove)) {	    m_ptr->ml = TRUE;	/* works correctly even if hallucinating */	    c_print(CC(c_list[m_ptr->mptr].color,(char)c_list[m_ptr->mptr].cchar), (int)m_ptr->fy,		  (int)m_ptr->fx);	    flag = TRUE;	}    }    if (flag) {	msg_print("You sense the presence of invisible creatures!");	msg_print(NULL);    /* must unlight every monster just lighted */	creatures(FALSE);    }    return (flag);}/* Split out of light_line.       -DGK */void mon_light_dam(y, x, dam)int y, x, dam;{    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    int                     i;    c_ptr = &cave[y][x];    if (c_ptr->cptr > 1) {	m_ptr = &m_list[c_ptr->cptr];	r_ptr = &c_list[m_ptr->mptr];	monster_name(m_name, m_ptr, r_ptr);	m_ptr->csleep = 0;	if (HURT_LIGHT & r_ptr->cdefense) {	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= HURT_LIGHT;	    i = mon_take_hit((int)c_ptr->cptr, dam, FALSE);	    if (i >= 0) {		(void)sprintf(out_val, "%s shrivels away in the light!", m_name);		msg_print(out_val);		prt_experience();	    } else {		(void)sprintf(out_val, "%s cringes from the light!", m_name);		msg_print(out_val);	    }	}    }}int light_area(y, x, dam, rad)	   /* Expanded -DGK */register int y, x, dam, rad;{    register int i, j;    int          min_i, max_i, min_j, max_j;    if (rad < 1) rad = 1;	/* sanity check -CWS */    if (py.flags.blind < 1)	msg_print("You are surrounded by a white light.");    if ((cave[y][x].fval == LIGHT_FLOOR) && (panel_contains(y, x)))	light_room(y, x);    if (cave[y][x].lr && (dun_level > 0) && !(cave[y][x].pl))		light_room(y, x); /* dbd - fix lighting radius */    /* replace a check for in_bounds2 every loop with 4 quick computations -CWS */    min_i = MY_MAX(0, (y - rad));    max_i = MY_MIN(cur_height - 1, (y + rad));    min_j = MY_MAX(0, (x - rad));    max_j = MY_MIN(cur_width - 1, (x + rad));    for (i = min_i; i <= max_i; i++)	for (j = min_j; j <= max_j; j++)	    if (los(y, x, i, j) && (distance(y, x, i, j) <= rad)) {		if (cave[i][j].lr && (dun_level > 0))		    light_room(i, j);		cave[i][j].pl = TRUE;		lite_spot(i, j);		if (dam)		    mon_light_dam(i, j, dam / (rad == 0 ? 1 : rad));	    }    return (TRUE);}/* Darken an area, opposite of light area		-RAK-	 */int unlight_area(y, x)int y, x;{    register int        i, j, unlight;    register cave_type *c_ptr;    int                 min_i, max_i, min_j, max_j;    unlight = FALSE;    if (cave[y][x].lr && (dun_level > 0)) {	darken_room(y, x);	unlight = TRUE;/* this isn't really good, as it returns true, even if rm was already dark, but * at least scrolls of darkness will be IDed when used -CFT */    } else {	min_i = MY_MAX(0, (y - 3));	max_i = MY_MIN(cur_height - 1, (y + 3));	min_j = MY_MAX(0, (x - 3));	max_j = MY_MIN(cur_width - 1, (x + 3));		/* replace a check for in_bounds2 every loop with 4 quick computations -CWS */		for (i = min_i; i <= max_i; i++)	    for (j = min_j; j <= max_j; j++) {		c_ptr = &cave[i][j];		if ((c_ptr->fval == CORR_FLOOR) && (c_ptr->pl || c_ptr->lr)) {		    /* pl could have been set by star-lite wand, etc */		    c_ptr->pl = FALSE;		    c_ptr->tl = FALSE;		    unlight = TRUE;		}	    }    }    if (unlight && py.flags.blind <= 0)	msg_print("Darkness surrounds you.");    return (unlight);}/* Map the current area plus some			-RAK-	 */void map_area(){    register cave_type *c_ptr;    register int        i7, i8, n, m;    int                 i, j, k, l;    i = panel_row_min - randint(10);    j = panel_row_max + randint(10);    k = panel_col_min - randint(20);    l = panel_col_max + randint(20);    for (m = i; m <= j; m++)	for (n = k; n <= l; n++)	    if (in_bounds(m, n) && (cave[m][n].fval <= MAX_CAVE_FLOOR))		for (i7 = m - 1; i7 <= m + 1; i7++)		    for (i8 = n - 1; i8 <= n + 1; i8++) {			c_ptr = &cave[i7][i8];			if (c_ptr->fval >= MIN_CAVE_WALL)			    c_ptr->pl = TRUE;			else if ((c_ptr->tptr != 0) &&			     (t_list[c_ptr->tptr].tval >= TV_MIN_VISIBLE) &&			       (t_list[c_ptr->tptr].tval <= TV_MAX_VISIBLE))			    c_ptr->fm = TRUE;		    }    prt_map();}/* Identify an object					-RAK-	 */int ident_spell(){    int                 item_val;    bigvtype            out_val, tmp_str;    register int        ident;    register inven_type *i_ptr;    ident = FALSE;    switch (get_item(&item_val, "Item you wish identified?", 0,		     INVEN_ARRAY_SIZE, 0))	{	case TRUE:	    ident = TRUE;	    identify(&item_val);	    i_ptr = &inventory[item_val];	    known2(i_ptr);	    objdes(tmp_str, i_ptr, TRUE);	    if (item_val >= INVEN_WIELD) {		calc_bonuses();				(void)sprintf(out_val, "%s: %s. ",			      describe_use(item_val), tmp_str);	    }  else {		(void)sprintf(out_val, "(%c) %s. ", item_val + 97, tmp_str);		changeinven();		}	    msg_print(out_val);	    break;	case FUZZY:	    ident = TRUE;	    i_ptr = &t_list[cave[char_row][char_col].tptr];	    /* that piece of code taken from desc.c:identify()	     * no use to convert type for calling identify since obj	     * on floor can't stack	     */	    if ((i_ptr->flags & TR_CURSED) && (i_ptr->tval != TV_MAGIC_BOOK) &&		(i_ptr->tval != TV_PRAYER_BOOK))		add_inscribe(i_ptr, ID_DAMD);	    if (!known1_p(i_ptr))		known1(i_ptr);	    /* end of identify-code */	    known2(i_ptr);	    objdes(tmp_str, i_ptr, TRUE);	    (void) sprintf(out_val, "%c %s", item_val+97, tmp_str);	    msg_print(out_val+2);	    break;	default:	    break;	    	}    return (ident);}/* Get all the monsters on the level pissed off.	-RAK-	 */int aggravate_monster(dis_affect)int dis_affect;{    register int           i, aggravate;    register monster_type *m_ptr;    aggravate = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	m_ptr->csleep = 0;	if ((m_ptr->cdis <= dis_affect) && (m_ptr->cspeed < 2)) {	    m_ptr->cspeed++;	    aggravate = TRUE;	}    }    if (aggravate)	msg_print("You hear a sudden stirring in the distance!");    return (aggravate);}/* Surround the fool with traps (chuckle)		-RAK-	 */int trap_creation(){    register int        i, j, trap;    register cave_type *c_ptr;    trap = FALSE;    for (i = char_row - 1; i <= char_row + 1; i++)	for (j = char_col - 1; j <= char_col + 1; j++) {	    if ((i == char_row) && (j == char_col))		continue;	   /* no trap under player, from um55 -CFT */	    c_ptr = &cave[i][j];	    if (c_ptr->fval <= MAX_CAVE_FLOOR) {		if ((c_ptr->tptr == 0) ||		    ((t_list[c_ptr->tptr].tval != TV_UP_STAIR)		     /* if not stairs or a store */		     &&(t_list[c_ptr->tptr].tval != TV_DOWN_STAIR)		     && (t_list[c_ptr->tptr].tval != TV_STORE_DOOR)) ||		    (t_list[c_ptr->tptr].tval < TV_MIN_WEAR) ||		    (t_list[c_ptr->tptr].tval > TV_MAX_WEAR) ||		    !(t_list[c_ptr->tptr].flags2 & TR_ARTIFACT)) {				/* if no artifact here -CFT */		    trap = TRUE;		    if (c_ptr->tptr != 0)			(void)delete_object(i, j);		    place_trap(i, j, randint(MAX_TRAP) - 1);		/* don't let player gain exp from the newly created traps */		    t_list[c_ptr->tptr].p1 = 0;		/* open pits are immediately visible, so call lite_spot */		    lite_spot(i, j);		} else		    msg_print("The object resists the spell.");	    }	}    return (trap);}/* Destroys any adjacent door(s)/trap(s)		-RAK-	 */int td_destroy(){    register int        i, j, destroy;    register cave_type *c_ptr;    destroy = FALSE;    for (i = char_row - 1; i <= char_row + 1; i++)	for (j = char_col - 1; j <= char_col + 1; j++) {	    c_ptr = &cave[i][j];	    if (c_ptr->tptr != 0) {		if (((t_list[c_ptr->tptr].tval >= TV_INVIS_TRAP) &&		     (t_list[c_ptr->tptr].tval <= TV_CLOSED_DOOR) &&		     (t_list[c_ptr->tptr].tval != TV_RUBBLE)) ||		    (t_list[c_ptr->tptr].tval == TV_SECRET_DOOR)) {		    if (delete_object(i, j))			destroy = TRUE;		} else if (t_list[c_ptr->tptr].tval == TV_CHEST) {		/* destroy traps on chest and unlock */		    t_list[c_ptr->tptr].flags &= ~(CH_TRAPPED | CH_LOCKED);		    t_list[c_ptr->tptr].name2 = SN_DISARMED;		    msg_print("You have disarmed the chest.");		    known2(&t_list[c_ptr->tptr]);		    destroy = TRUE;		}	    }	}    return (destroy);}/* Display all creatures on the current panel		-RAK-	 */int detect_monsters(){    register int        i, detect;    register monster_type *m_ptr;    detect = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	if (panel_contains((int)m_ptr->fy, (int)m_ptr->fx) &&	    ((CM_INVISIBLE & c_list[m_ptr->mptr].cmove) == 0)) {	    m_ptr->ml = TRUE;	/* works correctly even if hallucinating */	    c_print(CC(c_list[m_ptr->mptr].color,(char)c_list[m_ptr->mptr].cchar), (int)m_ptr->fy,		  (int)m_ptr->fx);	    detect = TRUE;	}    }    if (detect) {	msg_print("You sense the presence of monsters!");	msg_print(NULL);    /* must unlight every monster just lighted */	creatures(FALSE);    }    return (detect);}/* Leave a line of light in given dir, blue light can sometimes	 *//* hurt creatures.				       -RAK-   */void light_line(dir, y, x)int dir, y, x;{    register cave_type *c_ptr;    int                 dist, flag;    dist = (-1);    flag = FALSE;    do {    /* put mmove at end because want to light up current spot */	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	if (!c_ptr->pl && !c_ptr->tl) {	/* set pl so that lite_spot will work */	    c_ptr->pl = TRUE;	    if (c_ptr->fval == LIGHT_FLOOR) {		if (panel_contains(y, x))		    light_room(y, x);	    } else		lite_spot(y, x);	}    /* set pl in case tl was true above */	c_ptr->pl = TRUE;	mon_light_dam(y, x, damroll(6, 8));	(void)mmove(dir, &y, &x);    }    while (!flag);}/* Light line in all directions				-RAK-	 */void starlite(y, x)register int y, x;{    register int i;    if (py.flags.blind < 1)	msg_print("The end of the staff bursts into a blue shimmering light.");    for (i = 1; i <= 9; i++)	if (i != 5)	    light_line(i, y, x);}/* Disarms all traps/chests in a given direction	-RAK-	 */int disarm_all(dir, y, x)int dir, y, x;{    register cave_type  *c_ptr;    register inven_type *t_ptr;    register int         disarm, dist;    disarm = FALSE;    dist = (-1);    do {    /* put mmove at end, in case standing on a trap */	dist++;	c_ptr = &cave[y][x];    /* note, must continue upto and including the first non open space,     * because secret doors have fval greater than MAX_OPEN_SPACE      */	if (c_ptr->tptr != 0) {	    t_ptr = &t_list[c_ptr->tptr];	    if ((t_ptr->tval == TV_INVIS_TRAP) || (t_ptr->tval == TV_VIS_TRAP)) {		if (delete_object(y, x))		    disarm = TRUE;	    } else if (t_ptr->tval == TV_CLOSED_DOOR)		t_ptr->p1 = 0;	   /* Locked or jammed doors become merely closed. */	    else if (t_ptr->tval == TV_SECRET_DOOR) {		c_ptr->fm = TRUE;		change_trap(y, x);		disarm = TRUE;	    } else if ((t_ptr->tval == TV_CHEST) && (t_ptr->flags != 0)) {		msg_print("Click!");		t_ptr->flags &= ~(CH_TRAPPED | CH_LOCKED);		disarm = TRUE;		t_ptr->name2 = SN_UNLOCKED;		known2(t_ptr);	    }	}	(void)mmove(dir, &y, &x);    }    while ((dist <= OBJ_BOLT_RANGE) && c_ptr->fval <= MAX_OPEN_SPACE);    return (disarm);}/* Shoot a bolt in a given direction			-RAK-	 */void fire_bolt(typ, dir, y, x, dam_hp)int typ, dir, y, x, dam_hp;{    int                 i, oldy, oldx, dist, flag;/*    int32u              harm_type = 0; */    register cave_type *c_ptr;    register monster_type *m_ptr;    register creature_type *r_ptr;    vtype               out_val, m_name;    int                 dam = dam_hp;    int                 ny, nx;    char                bolt_char;    flag = FALSE;    oldy = y;    oldx = x;    dist = 0;    do {	ny = y;	nx = x;	(void)mmove(dir, &y, &x);    /* choose the right shape for the bolt... -CFT */	if (ny == y)	    bolt_char = '-';	else if (nx == x)	    bolt_char = '|';	else if ((ny - y) == (nx - x))	    bolt_char = '\\';	else	    bolt_char = '/';	dist++;	c_ptr = &cave[y][x];	lite_spot(oldy, oldx);	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else {	    if (c_ptr->cptr > 1) {		flag = TRUE;		m_ptr = &m_list[c_ptr->cptr];		r_ptr = &c_list[m_ptr->mptr];	    /*	     * light up monster and draw monster, temporarily set pl so that	     * update_mon() will work 	     */		i = c_ptr->pl;		c_ptr->pl = TRUE;		update_mon((int)c_ptr->cptr);		c_ptr->pl = i;	    /* draw monster and clear previous bolt */		put_qio();		spell_hit_monster(m_ptr, typ, &dam, 0, &ny, &nx, TRUE);		c_ptr = &cave[ny][nx];	/* may be new location if teleported					 * by gravity warp... */		m_ptr = &m_list[c_ptr->cptr];	/* and even if not, may be						 * new monster if chaos						 * polymorphed */		r_ptr = &c_list[m_ptr->mptr];		monster_name(m_name, m_ptr, r_ptr);		if ((dam > 0) && (m_ptr->hp >= dam)) {		    (void)sprintf(out_val,			       pain_message((int)c_ptr->cptr, dam), m_name);		    msg_print(out_val);		}		i = mon_take_hit((int)c_ptr->cptr, dam, TRUE);		if (i >= 0)		    prt_experience();	    } else if (panel_contains(y, x) && (py.flags.blind < 1)) {		c_print(CC(spell_color(typ),bolt_char), y, x);	    /* show the bolt */		put_qio();#ifdef MSDOS		delay(8 * delay_spd);	/* milliseconds */#else		usleep(8000 * delay_spd);	/* useconds */#endif	    }	}	oldy = y;	oldx = x;#ifdef TARGET	if (target_mode && at_target(y,x))	    flag = TRUE; /* must have hit "targeted" area -CFT */#endif    }    while (!flag);    lite_spot(oldy, oldx);	   /* just in case, clear any leftover bolt images -CFT */}/* Shoot a bolt in a given direction                    -RAK-   *//* heavily modified to include exotic bolts -CFT */void bolt(typ, y, x, dam_hp, ddesc, ptr, monptr)int           typ, y, x, dam_hp;char         *ddesc;monster_type *ptr;int           monptr;{    int                 i = ptr->fy, j = ptr->fx;    int                 dam;    int32u              tmp, treas;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    char                bolt_char;    int                 blind = (py.flags.status & PY_BLIND) ? 1 : 0;    int                 ny, nx, sourcey, sourcex, dist;    vtype               m_name, out_val;    sourcey = i;    sourcex = j;    dist = 0;    do {    /* This is going along a badly angled line so call mmove2 direct */	ny = i;	nx = j;	mmove2(&i, &j, sourcey, sourcex, char_row, char_col);	dist++;    /* choose the right shape for the bolt... -CFT */	if (ny == i)	    bolt_char = '-';	else if (nx == j)	    bolt_char = '|';	else if ((ny - i) == (nx - j))	    bolt_char = '\\';	else	    bolt_char = '/';	if (in_bounds(i, j) && los(y, x, i, j)) {	    c_ptr = &cave[i][j];	    if (c_ptr->fval <= MAX_OPEN_SPACE) {		if (panel_contains(i, j) && !(py.flags.status & PY_BLIND)) {		    c_print(CC(spell_color(typ),bolt_char), i, j);		    put_qio();#ifdef MSDOS		    delay(8 * delay_spd);	/* milliseconds */#else		    usleep(8000 * delay_spd);	/* useconds */#endif		    lite_spot(i, j);		}		if (c_ptr->cptr > 1 && c_ptr->cptr != monptr) {		    m_ptr = &m_list[c_ptr->cptr];		    dam = dam_hp;		    spell_hit_monster(m_ptr, typ, &dam, 0, &ny, &nx, FALSE);				/* process hit effects */		    /* may be new location if teleported by gravity warp... */		    c_ptr = &cave[ny][nx];		    /* and even if not, may be new monster if chaos polymorphed */		    m_ptr = &m_list[c_ptr->cptr];		    r_ptr = &c_list[m_ptr->mptr];		    monster_name(m_name, m_ptr, r_ptr);		    if (dam < 1)			dam = 1;   /* protect vs neg damage -CFT */		    m_ptr->hp = m_ptr->hp - dam;		    m_ptr->csleep = 0;/* prevent unique monster from death by other monsters.  It causes trouble * (monster not marked as dead, quest monsters don't satisfy quest, etc). * So, we let them live, but extremely wimpy. -CFT */		    if ((r_ptr->cdefense & UNIQUE) && (m_ptr->hp < 0))			m_ptr->hp = 0;		    if (m_ptr->hp < 0) {			object_level = (dun_level + r_ptr->level) >> 1;			coin_type = 0;			get_coin_type(r_ptr);			treas = monster_death((int)m_ptr->fy, (int)m_ptr->fx,					      r_ptr->cmove, 0, 0);			coin_type = 0;			if (m_ptr->ml || (c_list[m_ptr->mptr].cdefense & UNIQUE)) {			    tmp = (c_recall[m_ptr->mptr].r_cmove & CM_TREASURE)				>> CM_TR_SHIFT;			    if (tmp > ((treas & CM_TREASURE) >> CM_TR_SHIFT))				treas = (treas & ~CM_TREASURE) | (tmp << CM_TR_SHIFT);			    c_recall[m_ptr->mptr].r_cmove = treas |				(c_recall[m_ptr->mptr].r_cmove & ~CM_TREASURE);			}			if (monptr < c_ptr->cptr)			    delete_monster((int)c_ptr->cptr);			else			    fix1_delete_monster((int)c_ptr->cptr);		    } else {			(void)sprintf(out_val, pain_message((int)c_ptr->cptr, dam),				      m_name);			msg_print(out_val);		    }		    break;		} else if (c_ptr->cptr == 1) {		    if (dam_hp < 1)			dam_hp = 1;		    m_ptr = &m_list[monptr];		    switch (typ) {		      case GF_LIGHTNING:			if (blind)			    msg_print("You are hit by electricity!");			light_dam(dam_hp, ddesc);			break;		      case GF_POISON_GAS:			if (blind)			    msg_print("You are hit by a blast of noxious gases!");			poison_gas(dam_hp, ddesc);			break;		      case GF_ACID:			if (blind)			    msg_print("You are hit by a jet of acidic fluid!");			acid_dam(dam_hp, ddesc);			break;		      case GF_FROST:			if (blind)			    msg_print("You are hit by something cold!");			cold_dam(dam_hp, ddesc);			break;		      case GF_FIRE:			if (blind)			    msg_print("You are hit by something hot!");			fire_dam(dam_hp, ddesc);			break;		      case GF_MAGIC_MISSILE:			if (blind)			    msg_print("You are hit by something!");			take_hit(dam_hp, ddesc);			break;		      case GF_HOLY_ORB:			if (blind)			    msg_print("You are hit by something!");			dam_hp /= 2;	/* player should take less damage					 * -CFT */			take_hit(dam_hp, ddesc);			break;		      case GF_ARROW:	/* maybe can miss? */			if (blind)			    msg_print("You are hit by something!");			take_hit(dam_hp, ddesc);			break;		      case GF_PLASMA:	/* no resist to plasma? */			if (blind)			    msg_print("You are hit by something!");			take_hit(dam_hp, ddesc);			break;		      case GF_NETHER:			if (blind)			    msg_print("You are hit by an unholy blast!");			if (py.flags.nether_resist) {			    dam_hp *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */			    dam_hp /= (randint(6) + 6);	/* .858 to .5 -CFT */			} else {   /* no resist */			    if (py.flags.hold_life && randint(5) > 1)				msg_print("You keep hold of your life force!");			    else if (py.flags.hold_life) {				msg_print("You feel your life slipping away!");				lose_exp(200 + (py.misc.exp / 1000) * MON_DRAIN_LIFE);			    } else {				msg_print("You feel your life draining away!");				lose_exp(200 + (py.misc.exp / 100) * MON_DRAIN_LIFE);			    }			}			take_hit(dam_hp, ddesc);			break;		      case GF_WATER:			if (blind)			    msg_print("You are hit by a jet of water!");			if (!py.flags.sound_resist)			    stun_player(randint(15));			take_hit(dam_hp, ddesc);			break;		      case GF_CHAOS:			if (blind)			    msg_print("You are hit by wave of entropy!");			if (py.flags.chaos_resist) {			    dam_hp *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */			    dam_hp /= (randint(6) + 6);	/* .858 to .5 -CFT */			}			if ((!py.flags.confusion_resist) && (!py.flags.chaos_resist)) {			    if (py.flags.confused > 0)				py.flags.confused += 12;			    else				py.flags.confused = randint(20) + 10;			}			if (!py.flags.chaos_resist)			    py.flags.image += randint(10);			take_hit(dam_hp, ddesc);			break;		      case GF_SHARDS:			if (blind)			    msg_print("You are cut by sharp fragments!");			if (py.flags.shards_resist) {			    dam_hp *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */			    dam_hp /= (randint(6) + 6);	/* .858 to .5 -CFT */			} else {			    cut_player(dam_hp);	/* ouch! */			}			take_hit(dam_hp, ddesc);			break;		      case GF_SOUND:			if (blind)			    msg_print("You are deafened by a blast of noise!");			if (py.flags.sound_resist) {			    dam_hp *= 5;			    dam_hp /= (randint(6) + 6);			} else {			    stun_player(randint((dam_hp > 60) ? 25 : (dam_hp / 3 + 5)));			}			take_hit(dam_hp, ddesc);			break;		      case GF_CONFUSION:			if (blind)			    msg_print("You are hit by a wave of dizziness!");			if (py.flags.confusion_resist) {			    dam_hp *= 5;			    dam_hp /= (randint(6) + 6);			}			if (!py.flags.confusion_resist && !py.flags.chaos_resist) {			    if (py.flags.confused > 0)				py.flags.confused += 8;			    else				py.flags.confused = randint(15) + 5;			}			take_hit(dam_hp, ddesc);			break;		      case GF_DISENCHANT:			if (blind)			    msg_print("You are hit by something!");			if (py.flags.disenchant_resist) {			    dam_hp *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */			    dam_hp /= (randint(6) + 6);	/* .858 to .5 -CFT */			} else {			    int8u               disenchant = FALSE;			    int8u               chance;			    int                 t = 0;			    inven_type         *i_ptr;			    switch (randint(7)) {			      case 1:				t = INVEN_BODY;				break;			      case 2:				t = INVEN_BODY;				break;			      case 3:				t = INVEN_ARM;				break;			      case 4:				t = INVEN_OUTER;				break;			      case 5:				t = INVEN_HANDS;				break;			      case 6:				t = INVEN_HEAD;				break;			      case 7:				t = INVEN_FEET;				break;			    }			    i_ptr = &inventory[t];			    chance = 1;			    if (i_ptr->flags2 & TR_ARTIFACT)	/* Artifacts have 2/3 */				chance = randint(3);	/* chance to resist -DGK */			    if ((i_ptr->tohit > 0) && (chance == 1)) {				i_ptr->tohit -= randint(2);			    /* don't send it below zero */				if (i_ptr->tohit < 0)				    i_ptr->tohit = 0;				disenchant = TRUE;			    }			    if ((i_ptr->todam > 0) && (chance == 1)) {				i_ptr->todam -= randint(2);			    /* don't send it below zero */				if (i_ptr->todam < 0)				    i_ptr->todam = 0;				disenchant = TRUE;			    }			    if ((i_ptr->toac > 0) && (chance == 1)) {				i_ptr->toac -= randint(2);			    /* don't send it below zero */				if (i_ptr->toac < 0)				    i_ptr->toac = 0;				disenchant = TRUE;			    }			    if (disenchant || (chance != 1)) {				vtype               t1, t2;				objdes(t1, &inventory[t], FALSE);				if (disenchant)				    sprintf(t2, "Your %s (%c) %s disenchanted!", t1,					    inven_letter(i_ptr),					    (i_ptr->number != 1) ? "were" : "was");				else				    sprintf(t2, "Your %s (%c) %s disenchantment!", t1,					    inven_letter(i_ptr),					    (i_ptr->number != 1) ?					    "resist" : "resists");				msg_print(t2);				calc_bonuses();			    }			}			take_hit(dam_hp, ddesc);			break;/* no spec. effects from nexus bolt, only breath -CFT */		      case GF_NEXUS:			if (blind)			    msg_print("You are hit by something strange!");			if (py.flags.nexus_resist) {			    dam_hp *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */			    dam_hp /= (randint(6) + 6);	/* .858 to .5 -CFT */			}			take_hit(dam_hp, ddesc);			break;		      case GF_FORCE:			if (blind)			    msg_print("You are hit hard by a sudden force!");			if (!py.flags.sound_resist)			    stun_player(randint(15) + 1);			take_hit(dam_hp, ddesc);			break;		      case GF_INERTIA:			if (blind)			    msg_print("You are hit by something!");			if ((py.flags.slow > 0) && (py.flags.slow < 32000))			    py.flags.slow += randint(5);			else {			    msg_print("You feel less able to move.");			    py.flags.slow = randint(5) + 3;			}			take_hit(dam_hp, ddesc);			break;		      case GF_LIGHT:			if (blind)			    msg_print("You are hit by something!");			if (py.flags.light_resist) {			    dam_hp *= 4;	/* these 2 lines give avg dam						 * of .444, ranging from */			    dam_hp /= (randint(6) + 6);	/* .556 to .333 -CFT */			} else if (!blind && !py.flags.blindness_resist) {			    msg_print("You are blinded by the flash!");			    py.flags.blind += randint(5) + 2;			}			take_hit(dam_hp, ddesc);			break;		      case GF_DARK:			if (blind)			    msg_print("You are hit by something!");			if (py.flags.dark_resist) {			    dam_hp *= 4;	/* these 2 lines give avg dam						 * of .444, ranging from */			    dam_hp /= (randint(6) + 6);	/* .556 to .333 -CFT */			} else if (!py.flags.blindness_resist) {			    if (!blind) {				msg_print("The darkness prevents you from seeing!");			    }				py.flags.blind += randint(5) + 2;			}			take_hit(dam_hp, ddesc);			break;		      case GF_TIME:	/* only some effects from time bolt					 * -CFT */			if (blind)			    msg_print("You are hit by something!");			if (randint(2) == 1) {			    msg_print("You feel life has clocked back.");			    lose_exp(m_ptr->hp + (py.misc.exp / 300) * MON_DRAIN_LIFE);			} else {			    int                 t = 0;			    switch (randint(6)) {			      case 1:				t = A_STR;				msg_print("You're not as strong as you used to be...");				break;			      case 2:				t = A_INT;				msg_print("You're not as bright as you used to be...");				break;			      case 3:				t = A_WIS;				msg_print("You're not as wise as you used to be...");				break;			      case 4:				t = A_DEX;				msg_print("You're not as agile as you used to be...");				break;			      case 5:				t = A_CON;				msg_print("You're not as hale as you used to be...");				break;			      case 6:				t = A_CHR;				msg_print("You're not as beautiful as you used to be...");				break;			    }			    py.stats.cur_stat[t] = (py.stats.cur_stat[t] * 3) / 4;			    if (py.stats.cur_stat[t] < 3)				py.stats.cur_stat[t] = 3;			    set_use_stat(t);			    prt_stat(t);			}			take_hit(dam_hp, ddesc);			break;		      case GF_GRAVITY:			if (blind)			    msg_print("You are hit by a surge of gravity!");			if ((!py.flags.sound_resist) && (!py.flags.ffall))	/* DGK */			    stun_player(randint(15) + 1);			if (py.flags.ffall) {	/* DGK */			    dam_hp *= 3;	/* these 2 lines give avg dam						 * of .25, ranging from */			    dam_hp /= (randint(6) + 6);	/* .427 to .25 -CFT */			} else {   /* DGK */			    if ((py.flags.slow > 0) && (py.flags.slow < 32000))				py.flags.slow += randint(5);			    else {				msg_print("You feel less able to move.");				py.flags.slow = randint(5) + 3;			    }			} /* DGK */			take_hit(dam_hp, ddesc);			break;		      case GF_MANA:			if (blind)			    msg_print("You are hit by a beam of power!");			take_hit(dam_hp, ddesc);			break;		      case GF_METEOR:			if (blind)			    msg_print("You are hit by something!");			take_hit(dam_hp, ddesc);			break;		      case GF_ICE:			if (blind)			    msg_print("You are hit by something cold and sharp!");			cold_dam(dam_hp, ddesc);			if (!py.flags.sound_resist)			    stun_player(randint(15) + 1);			if (!py.flags.shards_resist)			    cut_player(damroll(8, 10));			break;		      default:			msg_print("Unknown typ in bolt().  This may mean trouble.");		    }		    disturb(1, 0);		    break;		}	    }	}    } while ((i != char_row) || (j != char_col));}/* Shoot a ball in a given direction.  Note that balls have an  *//* area affect.                                       -RAK-   */void fire_ball(typ, dir, y, x, dam_hp, max_dis)int typ, dir, y, x, dam_hp, max_dis;{    register int        i, j;    int                 dam, thit, tkill, k, tmp, monptr;    int                 oldy, oldx, dist, flag;    int                 (*destroy) (inven_type*);    register cave_type *c_ptr;    register monster_type *m_ptr;    register creature_type *r_ptr;    int                 ny, nx;    char                bolt_char;    thit = 0;    tkill = 0;    ball_destroy(typ, &destroy);    flag = FALSE;    oldy = y;    oldx = x;    dist = 0;    do {	ny = y;	nx = x;/* we don't call mmove if targetting and at target.  This allow player to target * a ball spell at his position, to explode it around himself -CFT */	if (dir || !at_target(y,x))	    	    (void)mmove(dir, &y, &x);    /* choose the right shape for the bolt... -CFT */	if (ny == y)	    bolt_char = '-';	else if (nx == x)	    bolt_char = '|';	else if ((ny - y) == (nx - x))	    bolt_char = '\\';	else	    bolt_char = '/';	dist++;	lite_spot(oldy, oldx);	if (dist > OBJ_BOLT_RANGE)	    flag = TRUE;	else {	    c_ptr = &cave[y][x];	/* targeting code stolen from Morgul -CFT */	/* This test has been overhauled (twice):  basically, it now says: if	 * ((spell hits a wall) OR ((spell hits a creature) and ((not	 * targetting) or (at the target anyway) or (no line-of-sight to	 * target, so aiming unusable) or ((aiming at a monster) and (that	 * monster is unseen, so aiming unusable)))) OR ((we are targetting)	 * and (at the target location))) THEN the ball explodes... -CFT  	 */#ifndef TARGET	    if ((c_ptr->fval >= MIN_CLOSED_SPACE) ||		((c_ptr->cptr > 1))) {		flag = TRUE;	   /* THEN we decide to explode here. -CFT */		if (c_ptr->fval >= MIN_CLOSED_SPACE) {		    y = oldy;		    x = oldx;		}#else	    if ((c_ptr->fval >= MIN_CLOSED_SPACE) ||		((c_ptr->cptr > 1) &&		 (!target_mode || at_target(y, x) ||		  !los(target_row, target_col, char_row, char_col) ||		  ((target_mon < MAX_MALLOC) && !m_list[target_mon].ml))) ||		(target_mode && at_target(y, x))) {	        flag = TRUE;	   /* THEN we decide to explode here. -CFT */	        if (c_ptr->fval >= MIN_CLOSED_SPACE) {		    y = oldy;		    x = oldx;	        }#endif	    /* The ball hits and explodes.               */	    /* The explosion.                            */		for (i = y - max_dis; i <= y + max_dis; i++)		    for (j = x - max_dis; j <= x + max_dis; j++)		    {		    	if (!in_bounds(i,j)) continue;		    	if (distance(y,x,i,j) > max_dis) continue;		    	if (!los(char_row,char_col,i,j)) continue;		    	if (!los(y,x,i,j)) continue;		    	if (cave[i][j].fval > MAX_OPEN_SPACE) continue;		    	if (!panel_contains(i,j)) continue;		    	if (py.flags.blind >= 1) continue;			    c_print(CC(spell_color(typ),'*'), i, j);			}/*			if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis) &&			 los(char_row, char_col, i, j) && los(y, x, i, j) &&			    (cave[i][j].fval <= MAX_OPEN_SPACE) &&			    panel_contains(i, j) && (py.flags.blind < 1))			    {			    			    c_print(CC(spell_color(typ),'*'), i, j);				}*/		if (py.flags.blind < 1) {		    put_qio();#ifdef MSDOS		    delay(25 * delay_spd);	/* milliseconds */#else		    usleep(25000 * delay_spd);	/* useconds */#endif		}	    /* now erase the ball, since effects below may use msg_print, and	     * pause indefinitely, so we want ball gone before then -CFT 	     */		for (i = y - max_dis; i <= y + max_dis; i++)		    for (j = x - max_dis; j <= x + max_dis; j++)		    {		    	if (!in_bounds(i,j)) continue;		    	if (distance(y,x,i,j) > max_dis) continue;		    	if (!los(char_row,char_col,i,j)) continue;		    	if (!los(y,x,i,j)) continue;		    	if (cave[i][j].fval > MAX_OPEN_SPACE) continue;		    	if (!panel_contains(i,j)) continue;		    	if (py.flags.blind >= 1) continue;			    lite_spot(i, j);	/* draw what is below the '*' */			}/*			if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis) &&			 los(char_row, char_col, i, j) && los(y, x, i, j) &&			    (cave[i][j].fval <= MAX_OPEN_SPACE) &&			    panel_contains(i, j) && (py.flags.blind < 1)) {			    lite_spot(i, j);	/ draw what is below the '*' /			}*/		put_qio();	    /* First go over the area of effect, and destroy items...  Any	     * preexisting items will be affected, but items dropped by	     * killed monsters are assummed to have been "shielded" from the	     * effects the the monster's corpse.  This means that you no	     * longer have to be SO paranoid about using fire/frost/acid	     * balls. -CFT 	     */		for (i = y - max_dis; i <= y + max_dis; i++)		    for (j = x - max_dis; j <= x + max_dis; j++)			if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis)			    && los(y, x, i, j) && (cave[i][j].tptr != 0) &&			    (*destroy) (&t_list[cave[i][j].tptr]))			    (void)delete_object(i, j);		/* burn/corrode or OW destroy items in area of effect */	    /* now go over area of affect and DO something to monsters... */		for (i = y - max_dis; i <= y + max_dis; i++)		    for (j = x - max_dis; j <= x + max_dis; j++)			if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis)			    && los(y, x, i, j)) {			    c_ptr = &cave[i][j];			    if (c_ptr->fval <= MAX_OPEN_SPACE) {				if (c_ptr->cptr > 1) {				    dam = dam_hp;				    m_ptr = &m_list[c_ptr->cptr];				    spell_hit_monster(m_ptr, typ, &dam,				      (distance(i, j, y, x) + 1), &ny, &nx, TRUE);				    c_ptr = &cave[ny][nx];			/* may be new location if teleported by gravity warp... */				    m_ptr = &m_list[c_ptr->cptr];			/* and even if not, may be new monster if chaos polymorphed */				    r_ptr = &c_list[m_ptr->mptr];				    monptr = c_ptr->cptr;				/*				 * lite up creature if visible, temp set pl				 * so that update_mon works 				 */				    tmp = c_ptr->pl;				    c_ptr->pl = TRUE;				    update_mon((int)c_ptr->cptr);				    thit++;				    if (dam < 1)					dam = 1;	/* protect vs neg damage -CFT */				    k = mon_take_hit((int)c_ptr->cptr, dam, TRUE);				    if (k >= 0)					tkill++;				    c_ptr->pl = tmp;				}				lite_spot(i, j);	/* erase the ball... */			    }			}	    /* show ball of whatever */		put_qio();	    /* End  explosion.                   */		if (tkill == 1) {		    msg_print("There is a scream of agony!");		} else if (tkill > 1) {		    msg_print("There are several screams of agony!");		}		if (tkill >= 0)		    prt_experience();	    /* End ball hitting.                 */	    } else if (panel_contains(y, x) && (py.flags.blind < 1)) {#ifdef TC_COLOR		if (!no_color_flag)		    textcolor(bolt_color(typ));#endif		c_print(CC(spell_color(typ),bolt_char), y, x);		put_qio();#ifdef TC_COLOR		if (!no_color_flag)		    textcolor(LIGHTGRAY);#endif#ifdef MSDOS		delay(8 * delay_spd);	/* milliseconds */#else		usleep(8000 * delay_spd);	/* useconds */#endif	    }	    oldy = y;	    oldx = x;#ifdef TARGET	    if (target_mode && at_target(y,x))		flag = TRUE; /* must have hit "targetted" area -CFT */#endif	}    } while (!flag);}/* Lightning ball in all directions                        SM   */void starball(y, x)    register int        y, x;{    register int        i;    for (i = 1; i <= 9; i++)	if (i != 5)	    fire_ball(GF_LIGHTNING, i, y, x, 150, 3);}/* Breath weapon works like a fire_ball, but affects the player. *//* Note the area affect.                              -RAK-   */void breath(typ, y, x, dam_hp, ddesc, monptr)int   typ, y, x, dam_hp;char *ddesc;int   monptr;{    register int        i, j;    int                 dam, max_dis;    int32u              tmp, treas;    int                 (*destroy) (inven_type*);    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    int                 ny, nx;    int                 blind = (py.flags.status & PY_BLIND) ? 1 : 0;    char                ch;    m_ptr = &m_list[monptr];    r_ptr = &c_list[m_ptr->mptr];    ch = r_ptr->cchar;    if ((ch == 'v' || ch == 'D' || ch == 'E' || ch == '&' || ch == 'A') ||	((ch == 'd' || ch == 'R') && r_ptr->cdefense & UNIQUE))	max_dis = 3;    else	max_dis = 2;    ball_destroy(typ, &destroy);    if (!(py.flags.status & PY_BLIND)) { /* only bother if the player can see */	for (i = y - max_dis; i <= y + max_dis; i++)	    for (j = x - max_dis; j <= x + max_dis; j++)		if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis) &&		    los(y, x, i, j) && (cave[i][j].fval <= MAX_OPEN_SPACE) &&		    panel_contains(i, j)) {#ifdef TC_COLOR		    if (!no_color_flag)			textcolor(bolt_color(typ));#endif		    c_print(CC(spell_color(typ),'*'), i, j);#ifdef TC_COLOR		    if (!no_color_flag)			textcolor(LIGHTGRAY);	/* prob don't need here, but... -CFT */#endif		}	put_qio();#ifdef MSDOS	delay(25 * delay_spd);	   /* milliseconds */#else	usleep(25000 * delay_spd); /* useconds */#endif /* now erase the ball, since effects below may use msg_print, and pause * indefinitely, so we want ball gone before then -CFT  */	for (i = y - max_dis; i <= y + max_dis; i++)	    for (j = x - max_dis; j <= x + max_dis; j++)		if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis) &&		    los(y, x, i, j) && (cave[i][j].fval <= MAX_OPEN_SPACE) &&		    panel_contains(i, j))		    lite_spot(i, j);   /* draw what is below the '*' */	put_qio();    }/* first, go over area of affect and destroy preexisting items. This change * means that any treasure dropped by killed monsters is safe from the effects * of this ball (but not from any later balls/breathes, even if they happen * before the player gets a chance to pick up that scroll of *Acquirement*).  * The assumption is made that this treasure was shielded from the effects by * the corpse of the killed monster. -CFT  */    for (i = y - max_dis; i <= y + max_dis; i++)	for (j = x - max_dis; j <= x + max_dis; j++)	    if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis)		&& los(y, x, i, j) && (cave[i][j].tptr != 0)		&& (*destroy) (&t_list[cave[i][j].tptr]))		delete_object(i, j);/* now go over area of affect and DO something to monsters */    for (i = y - max_dis; i <= y + max_dis; i++)	for (j = x - max_dis; j <= x + max_dis; j++)	    if (in_bounds(i, j) && (distance(y, x, i, j) <= max_dis)		&& los(y, x, i, j)) {		c_ptr = &cave[i][j];		if ((c_ptr->tptr != 0) && (*destroy) (&t_list[c_ptr->tptr]))		    (void)delete_object(i, j);		if (c_ptr->fval <= MAX_OPEN_SPACE) {		    if ((c_ptr->cptr > 1) && (c_ptr->cptr != monptr)) {			dam = dam_hp;			m_ptr = &m_list[c_ptr->cptr];			spell_hit_monster(m_ptr, typ, &dam, distance(i, j, y, x) + 1,					  &ny, &nx, FALSE);			c_ptr = &cave[ny][nx];	/* may be new location if teleported                                                 * by gravity warp... */			m_ptr = &m_list[c_ptr->cptr];	/* and even if not, may be new							 * monster if chaos polymorphed */			r_ptr = &c_list[m_ptr->mptr];		    /*		     * can not call mon_take_hit here, since player does not		     * get experience for kill 		     */			if (dam < 1)			    dam = 1;			m_ptr->hp = m_ptr->hp - dam;			m_ptr->csleep = 0;/* prevent unique monster from death by other monsters.  It causes trouble (monster not * marked as dead, quest monsters don't satisfy quest, etc).  So, we let * them live, but extremely wimpy.  This isn't great, because monster might heal * itself before player's next swing... -CFT */			if ((r_ptr->cdefense & UNIQUE) && (m_ptr->hp < 0))			    m_ptr->hp = 0;			if (m_ptr->hp < 0) {			    object_level = (dun_level + r_ptr->level) >> 1;				coin_type = 0;				get_coin_type(r_ptr);			    treas = monster_death((int)m_ptr->fy, (int)m_ptr->fx,						  r_ptr->cmove, 0, 0);				coin_type = 0;				/* recall even invisible uniques -CWS */			    if (m_ptr->ml || (c_list[m_ptr->mptr].cdefense & UNIQUE)) {				tmp = (c_recall[m_ptr->mptr].r_cmove & CM_TREASURE)				    >> CM_TR_SHIFT;				if (tmp > ((treas & CM_TREASURE) >> CM_TR_SHIFT))				    treas = (treas & ~CM_TREASURE) | (tmp << CM_TR_SHIFT);				c_recall[m_ptr->mptr].r_cmove = treas |				    (c_recall[m_ptr->mptr].r_cmove & ~CM_TREASURE);			    }			/* It ate an already processed monster.  Handle normally. */			    if (monptr < c_ptr->cptr)				delete_monster((int)c_ptr->cptr);/* If it eats this monster, an already processed monster will take its place, * causing all kinds of havoc. Delay the kill a bit. */			    else				fix1_delete_monster((int)c_ptr->cptr);			}		    } else if (c_ptr->cptr == 1) {			dam = (dam_hp / (distance(i, j, y, x) + 1));			m_ptr = &m_list[monptr];		    /* let's do at least one point of damage */		    /* prevents randint(0) problem with poison_gas, also */			if (dam <= 0)			    dam = 1;			if (dam > 1600)			    dam = 1600;			switch (typ) {			  case GF_LIGHTNING:			    light_dam(dam, ddesc);			    break;			  case GF_POISON_GAS:			    poison_gas(dam, ddesc);			    break;			  case GF_ACID:			    acid_dam(dam, ddesc);			    break;			  case GF_FROST:			    cold_dam(dam, ddesc);			    break;			  case GF_FIRE:			    fire_dam(dam, ddesc);			    break;			  case GF_MAGIC_MISSILE:			    take_hit(dam, ddesc);			    break;			  case GF_HOLY_ORB:			    dam /= 2;	/* player should take less damage					 * from "good" power-CFT */			    take_hit(dam, ddesc);			    break;			  case GF_ARROW:	/* maybe can miss? */			    take_hit(dam, ddesc);			    break;			  case GF_PLASMA:	/* no resist to plasma? */			    take_hit(dam, ddesc);			    if (!py.flags.sound_resist)				stun_player(randint(				(dam_hp > 40) ? 35 : (dam_hp * 3 / 4 + 5)));			    break;			  case GF_NETHER:			    if (py.flags.nether_resist) {				dam *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */				dam /= (randint(5) + 6);	/* .858 to .5 -CFT */			    } else {	/* no resist */				if (py.flags.hold_life && randint(3) > 1)				    msg_print("You keep hold of your life force!");				else if (py.flags.hold_life) {				    msg_print("You feel your life slipping away!");				    lose_exp(200 + (py.misc.exp/1000) * MON_DRAIN_LIFE);				} else {				    msg_print("You feel your life draining away!");				    lose_exp(200 + (py.misc.exp/100) * MON_DRAIN_LIFE);				}			    }			    take_hit(dam, ddesc);			    break;			  case GF_WATER:			    if (!py.flags.sound_resist)				stun_player(randint(55));			    if (!player_saves() && !py.flags.confusion_resist				&& !py.flags.chaos_resist) {				if ((py.flags.confused > 0) &&				    (py.flags.confused < 32000))				    py.flags.confused += 6;				else				    py.flags.confused = randint(8) + 6;			    }			    take_hit(dam, ddesc);			    break;			  case GF_CHAOS:			    if (py.flags.chaos_resist) {				dam *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */				dam /= (randint(6) + 6);	/* .858 to .5 -CFT */			    }			    if ((!py.flags.confusion_resist) &&				(!py.flags.chaos_resist)) {				if (py.flags.confused > 0)				    py.flags.confused += 12;				else				    py.flags.confused = randint(20) + 10;			    }			    if (!py.flags.chaos_resist)				py.flags.image += randint(10);			    if (!py.flags.nether_resist && !py.flags.chaos_resist) {				if (py.flags.hold_life && randint(3) > 1)				    msg_print("You keep hold of your life force!");				else if (py.flags.hold_life) {				    msg_print("You feel your life slipping away!");				    lose_exp(500 + (py.misc.exp/1000) * MON_DRAIN_LIFE);				} else {				    msg_print("You feel your life draining away!");				    lose_exp(5000 + (py.misc.exp/100) * MON_DRAIN_LIFE);				}			    }			    take_hit(dam, ddesc);			    break;			  case GF_SHARDS:			    if (py.flags.shards_resist) {				dam *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */				dam /= (randint(6) + 6);	/* .858 to .5 -CFT */			    } else {				cut_player(dam);	/* ouch! */			    }			    take_hit(dam, ddesc);			    break;			  case GF_SOUND:			    if (py.flags.sound_resist) {				dam *= 5;				dam /= (randint(6) + 6);			    } else {				stun_player(randint((dam > 90) ? 35 : (dam / 3 + 5)));			    }			    take_hit(dam, ddesc);			    break;			  case GF_CONFUSION:			    if (py.flags.confusion_resist) {				dam *= 5;	/* these 2 lines give avg dam						 * of .655, ranging from */				dam /= (randint(6) + 6);	/* .858 to .5 -CFT */			    }			    if (!py.flags.confusion_resist && !py.flags.chaos_resist) {				if (py.flags.confused > 0)				    py.flags.confused += 12;				else				    py.flags.confused = randint(20) + 10;			    }			    take_hit(dam, ddesc);			    break;			  case GF_DISENCHANT:			    if (py.flags.disenchant_resist) {				dam *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */				dam /= (randint(6) + 6);	/* .858 to .5 -CFT */			    } else {				int8u               disenchant = FALSE;				int8u               chance;				int                 t = 0;				inven_type         *i_ptr;				switch (randint(7)) {				  case 1:				    t = INVEN_BODY;				    break;				  case 2:				    t = INVEN_BODY;				    break;				  case 3:				    t = INVEN_ARM;				    break;				  case 4:				    t = INVEN_OUTER;				    break;				  case 5:				    t = INVEN_HANDS;				    break;				  case 6:				    t = INVEN_HEAD;				    break;				  case 7:				    t = INVEN_FEET;				    break;				}				i_ptr = &inventory[t];				chance = 1;				/* Artifacts have 2/3 chance to resist -DGK */				if (i_ptr->flags2 & TR_ARTIFACT)				    chance = randint(3);				if ((i_ptr->tohit > 0) && (chance == 1)) {				    i_ptr->tohit -= randint(2);				/* don't send it below zero */				    if (i_ptr->tohit < 0)					i_ptr->tohit = 0;				    disenchant = TRUE;				}				if ((i_ptr->todam > 0) && (chance == 1)) {				    i_ptr->todam -= randint(2);				/* don't send it below zero */				    if (i_ptr->todam < 0)					i_ptr->todam = 0;				    disenchant = TRUE;				}				if ((i_ptr->toac > 0) && (chance == 1)) {				    i_ptr->toac -= randint(2);				/* don't send it below zero */				    if (i_ptr->toac < 0)					i_ptr->toac = 0;				    disenchant = TRUE;				}				if (disenchant || (chance != 1)) {				    vtype               t1, t2;				    objdes(t1, &inventory[t], FALSE);				    if (disenchant)					sprintf(t2, "Your %s (%c) %s disenchanted!", t1,					        inven_letter(i_ptr),						(i_ptr->number != 1) ?						"were" : "was");				    else					sprintf(t2, "Your %s (%c) %s disenchantment!",						t1,					        inven_letter(i_ptr),						(i_ptr->number != 1) ?						"resist" : "resists");				    msg_print(t2);				    calc_bonuses();				}			    }			    take_hit(dam, ddesc);			    break;			  case GF_NEXUS:			    /* no spec. effects from nexus bolt, only breath -CFT */			    if (py.flags.nexus_resist) {				dam *= 6;	/* these 2 lines give avg dam						 * of .655, ranging from */				dam /= (randint(6) + 6);	/* .858 to .5 -CFT */			    } else {	/* special effects */				switch (randint(7)) {				  case 1:				  case 2:				  case 3:				    teleport(200);				    break;				  case 4:				  case 5:				    teleport_to((int)m_ptr->fy, (int)m_ptr->fx);				    break;				  case 6:				    if (player_saves())					msg_print("You resist the effects.");				    else {					int                 k = dun_level;					if (dun_level == Q_PLANE)					    dun_level = 0;					else if (is_quest(dun_level))					    dun_level -= 1;					else					    dun_level += (-3) + 2 * randint(2);					if (dun_level < 0)					    dun_level = 0;					if (k == Q_PLANE)			    msg_print("You warp through a cross-dimension gate.");					else if (k < dun_level)					    msg_print("You sink through the floor.");					else				    msg_print("You rise up through the ceiling.");					new_level_flag = TRUE;				    }				    break;				  case 7:				    if (player_saves() && randint(2) == 1)					msg_print("You resist the effects.");				    else {					int      max1, cur1, max2, cur2, ii, jj;					msg_print("Your body starts to scramble...");					ii = randint(6) - 1;					do {					    jj = randint(6) - 1;					} while (ii == jj);					max1 = py.stats.max_stat[ii];					cur1 = py.stats.cur_stat[ii];					max2 = py.stats.max_stat[jj];					cur2 = py.stats.cur_stat[jj];					py.stats.max_stat[ii] = max2;					py.stats.cur_stat[ii] = cur2;					py.stats.max_stat[jj] = max1;					py.stats.cur_stat[jj] = cur1;					set_use_stat(ii);					set_use_stat(jj);					prt_stat(ii);					prt_stat(jj);				    }				} /* switch for effects */			    }			    take_hit(dam, ddesc);			    break;			  case GF_FORCE:			    if (!py.flags.sound_resist)				stun_player(randint(20));			    take_hit(dam, ddesc);			    break;			  case GF_INERTIA:			    if ((py.flags.slow > 0) && (py.flags.slow < 32000))				py.flags.slow += randint(5);			    else {				msg_print("You feel less able to move.");				py.flags.slow = randint(5) + 3;			    }			    take_hit(dam, ddesc);			    break;			  case GF_LIGHT:			    if (py.flags.light_resist) {				dam *= 4;				dam /= (randint(6) + 6);			    } else if (!blind && !py.flags.blindness_resist) {				msg_print("You are blinded by the flash!");				py.flags.blind += randint(6) + 3;			    }			    light_area(char_row, char_col, 0, max_dis);			    take_hit(dam, ddesc);			    break;			  case GF_DARK:			    if (py.flags.dark_resist) {				dam *= 4;				dam /= (randint(6) + 6);			    } else				if (!blind && !py.flags.blindness_resist) {				    msg_print("The darkness prevents you from seeing!");				py.flags.blind += randint(5) + 2;			    }			    			    unlight_area(char_row, char_col);			    take_hit(dam, ddesc);			    break;			  case GF_TIME:	/* only some effects from time bolt -CFT */			    switch (randint(10)) {			      case 1:			      case 2:			      case 3:			      case 4:			      case 5:				msg_print("You feel life has clocked back.");				lose_exp(m_ptr->hp + (py.misc.exp / 300) * MON_DRAIN_LIFE);				break;			      case 6:			      case 7:			      case 8:			      case 9:				{				    int                 t = 0;				    switch (randint(6)) {				      case 1:					t = A_STR;				msg_print("You're not as strong as you used to be...");					break;				      case 2:					t = A_INT;				msg_print("You're not as bright as you used to be...");					break;				      case 3:					t = A_WIS;				msg_print("You're not as wise as you used to be...");					break;				      case 4:					t = A_DEX;				msg_print("You're not as agile as you used to be...");					break;				      case 5:					t = A_CON;				msg_print("You're not as hale as you used to be...");					break;				      case 6:					t = A_CHR;			msg_print("You're not as beautiful as you used to be...");					break;				    }			    py.stats.cur_stat[t] = (py.stats.cur_stat[t] * 3) / 4;				    if (py.stats.cur_stat[t] < 3)					py.stats.cur_stat[t] = 3;				    set_use_stat(t);				    prt_stat(t);				}				break;			      case 10:				{				    int                 ii;				    for (ii = 0; ii < 6; ii++) {				py.stats.cur_stat[ii] = (py.stats.cur_stat[ii] * 3) / 4;					if (py.stats.cur_stat[ii] < 3)					    py.stats.cur_stat[ii] = 3;					set_use_stat(ii);					prt_stat(ii);				    }				}				msg_print("You're not as strong as you used to be...");				msg_print("You're not as bright as you used to be...");				msg_print("You're not as wise as you used to be...");				msg_print("You're not as agile as you used to be...");				msg_print("You're not as hale as you used to be...");			msg_print("You're not as beautiful as you used to be...");				break;			    } /* randint(10) for effects */			    take_hit(dam, ddesc);			    break;			  case GF_GRAVITY:			    if ((!py.flags.sound_resist) && (!py.flags.ffall))	/* DGK */				stun_player(randint((dam > 90) ? 35 : (dam / 3 + 5)));			    if (py.flags.ffall) {	/* DGK */				dam_hp *= 3;	/* these 2 lines give avg dam						 * of .33, ranging from */				dam_hp /= (randint(6) + 6);	/* .427 to .25 -CFT */			    } else {	/* DGK */				if ((py.flags.slow > 0) && (py.flags.slow < 32000))				    py.flags.slow += randint(5);				else {				    msg_print("You feel less able to move.");				    py.flags.slow = randint(5) + 3;				}			    } /* DGK */			    msg_print("Gravity warps around you.");			    teleport(5);			    take_hit(dam, ddesc);			    break;			  case GF_MANA:			    take_hit(dam, ddesc);			    break;			  case GF_METEOR:			    take_hit(dam, ddesc);			    break;			  case GF_ICE:			    cold_dam(dam, ddesc);			    if (!py.flags.sound_resist)				stun_player(randint(25));			    if (!py.flags.shards_resist)				cut_player(damroll(8, 10));			    break;			  default:		    msg_print("Unknown typ in breath().  This may mean trouble.");			}		    }		}	    }/* show the ball of gas */    put_qio();/* erase ball and redraw */    for (i = (y - max_dis); i <= (y + max_dis); i++)	for (j = (x - max_dis); j <= (x + max_dis); j++)	    if (in_bounds(i, j) && panel_contains(i, j) &&		(distance(y, x, i, j) <= max_dis))		lite_spot(i, j);}int recharge(num)register int num;{    int                 i, j, k, l, item_val;    register int        res;    register inven_type *i_ptr;    int                 found = FALSE;    res = FALSE;    if (find_range(TV_STAFF, TV_WAND, &i, &j))	found = TRUE;    if (find_range(TV_ROD, TV_NEVER, &k, &l))	found = TRUE;    if (!found)	msg_print("You have nothing to recharge.");    else if (get_item(&item_val, "Recharge which item?",		      (k > -1) ? k : i, (j > -1) ? j : l, 0)) {	i_ptr = &inventory[item_val];	res = TRUE;	if (i_ptr->tval == TV_ROD) {	    /* now allow players to speed up recharge time of rods -CFT */	    int16u              t_o = i_ptr->timeout, t;	    if (randint((100 - i_ptr->level + num) / 5) == 1) {	/* not today... */		msg_print("The recharge backfires, and drains the rod further!");		if (t_o < 32000)   /* don't overflow... */		    i_ptr->timeout = (t_o + 100) * 2;	    } else {		t = (int16u) (num * damroll(2, 4));	/* rechange amount */		if (t_o < t)		    i_ptr->timeout = 0;		else		    i_ptr->timeout = t_o - t;	    }	}	 /* if recharge rod... */ 	else {			   /* recharge wand/staff */	/* recharge I = recharge(20) = 1/6 failure for empty 10th level wand   */	/* recharge II = recharge(60) = 1/10 failure for empty 10th level wand */	/* make it harder to recharge high level, and highly charged wands     */	    if (randint((num + 100 - (int)i_ptr->level - (10 * i_ptr->p1)) / 15) == 1) {		msg_print("There is a bright flash of light.");		inven_destroy(item_val);	    } else {		num = (num / (i_ptr->level + 2)) + 1;		i_ptr->p1 += 2 + randint(num);		if (known2_p(i_ptr))		    clear_known2(i_ptr);		clear_empty(i_ptr);		changeinven();	    }	}    }    return (res);}/* Increase or decrease a creatures hit points		-RAK-	 */int hp_monster(dir, y, x, dam)int dir, y, x, dam;{    register int        i;    int                 flag, dist, monster;    register cave_type *c_ptr;    register monster_type *m_ptr;    register creature_type *r_ptr;    vtype               out_val, m_name;    monster = FALSE;    flag = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    flag = TRUE;	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    monster_name(m_name, m_ptr, r_ptr);	    monster = TRUE;	    i = mon_take_hit((int)c_ptr->cptr, dam, TRUE);	    if (i >= 0) {		(void)sprintf(out_val, "%s dies in a fit of agony.", m_name);		msg_print(out_val);		prt_experience();	    } else if (dam > 0) {		(void)sprintf(out_val,			      pain_message((int)c_ptr->cptr, dam), m_name);		msg_print(out_val);	    }	}    }    while (!flag);    return (monster);}/* Drains life; note it must be living.		-RAK-	 */int drain_life(dir, y, x, dam)int dir, y, x, dam;{    register int            i;    int                     flag, dist, drain;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    drain = FALSE;    flag = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    flag = TRUE;	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    if (((r_ptr->cdefense & UNDEAD) == 0) &&		((r_ptr->cdefense & DEMON) == 0) &&		(r_ptr->cchar != 'E' && r_ptr->cchar != 'g' && r_ptr->cchar != 'v')) {		drain = TRUE;		monster_name(m_name, m_ptr, r_ptr);		i = mon_take_hit((int)c_ptr->cptr, dam, TRUE);		if (i >= 0) {		    (void)sprintf(out_val, "%s dies in a fit of agony.", m_name);		    msg_print(out_val);		    prt_experience();		} else {		    (void)sprintf(out_val,			       pain_message((int)c_ptr->cptr, dam), m_name);		    msg_print(out_val);		}	    } else {		if (r_ptr->cdefense & UNDEAD)		    c_recall[m_ptr->mptr].r_cdefense |= UNDEAD;		else		    c_recall[m_ptr->mptr].r_cdefense |= DEMON;	    }	}    }    while (!flag);    return (drain);}/* Increase or decrease a creatures speed		-RAK-	 *//* NOTE: cannot slow a winning creature (BALROG)		 */int speed_monster(dir, y, x, spd)int dir, y, x, spd;{    int                    flag, dist, speed;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    speed = FALSE;    flag = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    flag = TRUE;	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    monster_name(m_name, m_ptr, r_ptr);	    if (spd > 0) {		m_ptr->cspeed += spd;		m_ptr->csleep = 0;		(void)sprintf(out_val, "%s starts moving faster.", m_name);		msg_print(out_val);		speed = TRUE;	    } else if ((r_ptr->level >			randint((py.misc.lev - 10) < 1 ? 1 : (py.misc.lev - 10)) + 10) ||		       (r_ptr->cdefense & UNIQUE)) {		(void)sprintf(out_val, "%s is unaffected.", m_name);		msg_print(out_val);		m_ptr->csleep = 0;	    } else {		m_ptr->cspeed += spd;		m_ptr->csleep = 0;		(void)sprintf(out_val, "%s starts moving slower.", m_name);		msg_print(out_val);		speed = TRUE;	    }	}    }    while (!flag);    return (speed);}/* Confuse a creature					-RAK-	 */int confuse_monster(dir, y, x, lvl)int dir, y, x, lvl;{    int                     flag, dist, confuse;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    confuse = FALSE;    flag = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    monster_name(m_name, m_ptr, r_ptr);	    flag = TRUE;	    if ((r_ptr->level >	    randint((py.misc.lev - 10) < 1 ? 1 : (py.misc.lev - 10)) + 10) ||		(r_ptr->cdefense & UNIQUE ||		 r_ptr->spells2 & (BREATH_CO | BREATH_CH))) {		if (m_ptr->ml && (r_ptr->cdefense & CHARM_SLEEP))		    c_recall[m_ptr->mptr].r_cdefense |= CHARM_SLEEP;		(void)sprintf(out_val, "%s is unaffected.", m_name);		msg_print(out_val);		m_ptr->csleep = 0;	    } else {		if (m_ptr->confused < 230)		    m_ptr->confused += (int8u) (damroll(3, (lvl / 2)) + 1);		confuse = TRUE;		m_ptr->csleep = 0;		(void)sprintf(out_val, "%s appears confused.", m_name);		msg_print(out_val);	    }	}    }    while (!flag);    return (confuse);}/* Scare a creature -DGK */int fear_monster(dir, y, x, lvl)int dir, y, x, lvl;{    int                     flag, dist, fear;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    fear = FALSE;    flag = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    monster_name(m_name, m_ptr, r_ptr);	    flag = TRUE;	    if ((r_ptr->level >	    randint((py.misc.lev - 10) < 1 ? 1 : (py.misc.lev - 10)) + 10) ||		(r_ptr->cdefense & UNIQUE)) {		if (m_ptr->ml && (r_ptr->cdefense & CHARM_SLEEP))		    c_recall[m_ptr->mptr].r_cdefense |= CHARM_SLEEP;		(void)sprintf(out_val, "%s is unaffected.", m_name);		msg_print(out_val);		m_ptr->csleep = 0;	    } else {		if (m_ptr->monfear < 175)		    m_ptr->monfear += (int8u) (damroll(3, (lvl / 2)) + 1);		fear = TRUE;		m_ptr->csleep = 0;		(void)sprintf(out_val, "%s flees in terror!", m_name);		msg_print(out_val);	    }	}    }    while (!flag);    return (fear);}/* Sleep a creature.					-RAK-	 */int sleep_monster(dir, y, x)int dir, y, x;{    int                     flag, dist, sleep;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    sleep = FALSE;    flag = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    flag = TRUE;	    monster_name(m_name, m_ptr, r_ptr);	    if ((r_ptr->level >	    randint((py.misc.lev - 10) < 1 ? 1 : (py.misc.lev - 10)) + 10) ||	    (r_ptr->cdefense & UNIQUE) || (r_ptr->cdefense & CHARM_SLEEP)) {		if (m_ptr->ml && (r_ptr->cdefense & CHARM_SLEEP))		    c_recall[m_ptr->mptr].r_cdefense |= CHARM_SLEEP;		(void)sprintf(out_val, "%s is unaffected.", m_name);		msg_print(out_val);	    } else {		m_ptr->csleep = 500;		sleep = TRUE;		(void)sprintf(out_val, "%s falls asleep.", m_name);		msg_print(out_val);	    }	}    }    while (!flag);    return (sleep);}