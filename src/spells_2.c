/* * spells.c: code for player and creature spells, breaths, wands, scrolls, * etc.  * * Copyright (c) 1989 James E. Wilson, Robert A. Koeneke  * * This software may be copied and distributed for educational, research, and * not for profit purposes provided that this copyright and statement are * included in all such copies.  */#include "angband.h"#include "monster.h"#ifdef USG#ifndef ATARIST_MWC#include <string.h>#endif#else#ifndef VMS#include <strings.h>#endif#endif/* Lets do all prototypes correctly.... -CWS */#ifndef NO_LINT_ARGS#ifdef __STDC__char bolt_char(int, int, int, int);static void ball_destroy(int, int (**) (inven_type*));static void pause_if_screen_full(int *, int);void spell_hit_monster(monster_type *, int, int *, int, int *, int *, int);static void replace_spot(int, int, int);char inven_letter(inven_type *);int8u spell_color(int typ);#elsechar bolt_char();static void ball_destroy();static void pause_if_screen_full();void spell_hit_monster();static void replace_spot();char inven_letter();#endif#endif/* Turn stone to mud, delete wall.			-RAK-	 */int wall_to_mud(dir, y, x)int dir, y, x;{    int                     i, wall, dist;    bigvtype                out_val, tmp_str;    register int            flag;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   m_name;    wall = FALSE;    flag = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];    /* note, this ray can move through walls as it turns them to mud */	if (dist == OBJ_BOLT_RANGE)	    flag = TRUE;	if (c_ptr->fval == BOUNDARY_WALL) {	    flag = TRUE;	    if (test_light(y, x))		msg_print("The wall resists your spell.");	} else if ((c_ptr->fval >= MIN_CAVE_WALL)) {	    flag = TRUE;	    (void)twall(y, x, 1, 0);	    if (test_light(y, x)) {		msg_print("The wall turns into mud.");		check_view();		wall = TRUE;	    }	} else if ((c_ptr->tptr != 0) && (c_ptr->fval >= MIN_CLOSED_SPACE)) {	    flag = TRUE;	    if (panel_contains(y, x) && test_light(y, x)) {				objdes(tmp_str, &t_list[c_ptr->tptr], FALSE);		if ((t_list[c_ptr->tptr].tval == TV_RUBBLE) && (randint(10)==1)) {		    delete_object(y,x);		    place_object(y,x);		    lite_spot(y,x);		    (void) sprintf(out_val,			   "The %s turns into mud, revealing an object!",				   tmp_str);		}		else {		    (void) delete_object(y, x);		    (void) sprintf(out_val, "The %s turns into mud.", tmp_str);		}		msg_print(out_val);		check_view();		wall = TRUE;	    }	}		if (c_ptr->cptr > 1) {	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    if (HURT_ROCK & r_ptr->cdefense) {		monster_name(m_name, m_ptr, r_ptr);		flag = m_ptr->ml;		i = mon_take_hit((int)c_ptr->cptr, (20 + randint(30)), TRUE);		if (flag) {		    if (i >= 0) {			c_recall[i].r_cdefense |= HURT_ROCK;			(void)sprintf(out_val, "%s dissolves!", m_name);			msg_print(out_val);			prt_experience();	/* print msg before calling prt_exp */		    } else {			c_recall[m_ptr->mptr].r_cdefense |= HURT_ROCK;			(void)sprintf(out_val, "%s grunts in pain!", m_name);			msg_print(out_val);		    }		}		flag = TRUE;	    }	}    }    while (!flag);    return (wall);}/* Destroy all traps and doors in a given direction	-RAK-	 */int td_destroy2(dir, y, x)int dir, y, x;{    register int         destroy2, dist;    register cave_type  *c_ptr;    register inven_type *t_ptr;    destroy2 = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];    /* must move into first closed spot, as it might be a secret door */	if (c_ptr->tptr != 0) {	    t_ptr = &t_list[c_ptr->tptr];	    if (t_ptr->tval == TV_CHEST) /* let's untrap it instead -CWS */		t_ptr->flags &= ~(CH_TRAPPED | CH_LOCKED);	    else if ((t_ptr->tval == TV_INVIS_TRAP) || (t_ptr->tval == TV_VIS_TRAP) ||		     (t_ptr->tval == TV_OPEN_DOOR) || (t_ptr->tval == TV_CLOSED_DOOR)		     || (t_ptr->tval == TV_SECRET_DOOR)) {		if (delete_object(y, x)) {		    msg_print("There is a bright flash of light!");		    destroy2 = TRUE;		}	    }	}    }    while ((dist <= OBJ_BOLT_RANGE) || c_ptr->fval <= MAX_OPEN_SPACE);    return (destroy2);}/* polymorph is now uniform for poly/mass poly/choas poly, and only   as deadly as chaos poly is.  This still makes polymorphing a bad   idea, but it won't be automatically fatal. -CFT */static intpoly(mnum)int mnum;{    register creature_type *c_ptr = &c_list[m_list[mnum].mptr];    int y, x;    int i,j,k;        if (c_ptr->cdefense & UNIQUE) return 0;    y = m_list[mnum].fy;    x = m_list[mnum].fx;    i = (randint(20)/randint(9))+1;    k = j = c_ptr->level;    if ((j -=i)<0) j = 0;    if ((k +=i)>MAX_MONS_LEVEL) k = MAX_MONS_LEVEL;    delete_monster(mnum);    do {	i = randint(m_level[k]-m_level[j])-1+m_level[j];  /* new creature index */    } while (c_list[i].cdefense & UNIQUE);    place_monster(y,x,i,FALSE);    return 1;}/* polymorph now safer.  not safe, just safer -CFT *//* Polymorph a monster                                  -RAK-   *//* NOTE: cannot polymorph a winning creature (BALROG)            */intpoly_monster(dir, y, x)int dir, y, x;{    int                     dist, flag, flag2, p;    register cave_type     *c_ptr;    register creature_type *r_ptr;    register monster_type  *m_ptr;    vtype                   out_val, m_name;        p = FALSE;    flag = FALSE;    flag2= FALSE;    dist = 0;    do {	(void) mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    m_ptr = &m_list[c_ptr->cptr];	    r_ptr = &c_list[m_ptr->mptr];	    if ((r_ptr->level < randint((py.misc.lev-10)<1?1:(py.misc.lev-10))+10)                && !(r_ptr->cdefense & UNIQUE)) {		poly(c_ptr->cptr);		if (panel_contains(y, x) && (c_ptr->tl || c_ptr->pl))		    p = TRUE;	    } else {		monster_name (m_name, m_ptr, r_ptr);		(void) sprintf(out_val, "%s is unaffected.", m_name);		msg_print(out_val);	    }	}    }    while (!flag);    return(p);}/* Create a wall.					-RAK-	 */int build_wall(dir, y, x)int dir, y, x;{    register int            i;    int                     build, damage, dist, flag;    register cave_type     *c_ptr;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   m_name, out_val;    build = FALSE;    dist = 0;    flag = FALSE;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else {	    if (c_ptr->cptr > 1) {	    /* stop the wall building */		flag = TRUE;		m_ptr = &m_list[c_ptr->cptr];		r_ptr = &c_list[m_ptr->mptr];		if (!(r_ptr->cmove & CM_PHASE)) {		/* monster does not move, can't escape the wall */		    if (r_ptr->cmove & CM_ATTACK_ONLY)			damage = 250;		    else			damage = damroll(4, 8);		    monster_name(m_name, m_ptr, r_ptr);		    (void)sprintf(out_val, "%s wails out in pain!", m_name);		    msg_print(out_val);		    i = mon_take_hit((int)c_ptr->cptr, damage, TRUE);		    if (i >= 0) {			(void)sprintf(out_val, "%s is embedded in the rock.",				      m_name);			msg_print(out_val);		    /* prt_experience(); */		    }		} else if (r_ptr->cchar == 'E' || r_ptr->cchar == 'X') {		/*		 * must be an earth elemental or an earth spirit, or a Xorn		 * increase its hit points 		 */		    m_ptr->hp += damroll(4, 8);		}	    }	    if (c_ptr->tptr != 0)		if (((t_list[c_ptr->tptr].tval >= TV_MIN_WEAR) &&		     (t_list[c_ptr->tptr].tval <= TV_MAX_WEAR) &&		     (t_list[c_ptr->tptr].flags2 & TR_ARTIFACT))		    || (t_list[c_ptr->tptr].tval == TV_UP_STAIR)		    || (t_list[c_ptr->tptr].tval == TV_DOWN_STAIR)		    || (t_list[c_ptr->tptr].tval == TV_STORE_DOOR))		    continue;	   /* don't bury the artifact/stair/store */		else		    (void)delete_object(y, x);	    c_ptr->fval = MAGMA_WALL;	    c_ptr->fm = FALSE;	    lite_spot(y, x);	    i++;	    build = TRUE;	}    }    while (!flag);    return (build);}/* Replicate a creature					-RAK-	 */int clone_monster(dir, y, x)int dir, y, x;{    register cave_type *c_ptr;    register int        dist, flag;    dist = 0;    flag = FALSE;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    m_list[c_ptr->cptr].csleep = 0;            m_list[c_ptr->cptr].hp = m_list[c_ptr->cptr].maxhp;            if (randint(3) == 1)                m_list[c_ptr->cptr].cspeed += 1;	/* monptr of 0 is safe here, since can't reach here from creatures */	    return multiply_monster(y, x, (int)m_list[c_ptr->cptr].mptr, 0);	}    }    while (!flag);    return (FALSE);}/* Move the creature record to a new location		-RAK-	 */void teleport_away(monptr, dis)int monptr, dis;{    register int           yn, xn, ctr;    register monster_type *m_ptr;    m_ptr = &m_list[monptr];    ctr = 0;    do {	do {	    yn = m_ptr->fy + (randint(2 * dis + 1) - (dis + 1));	    xn = m_ptr->fx + (randint(2 * dis + 1) - (dis + 1));	}	while (!in_bounds(yn, xn));	ctr++;	if (ctr > 9) {	    ctr = 0;	    dis += 5;	}    }    while ((cave[yn][xn].fval >= MIN_CLOSED_SPACE) || (cave[yn][xn].cptr != 0));    move_rec((int)m_ptr->fy, (int)m_ptr->fx, yn, xn);    lite_spot((int)m_ptr->fy, (int)m_ptr->fx);    m_ptr->fy = yn;    m_ptr->fx = xn;/* this is necessary, because the creature is not currently visible in its * new position  */    m_ptr->ml = FALSE;    m_ptr->cdis = distance(char_row, char_col, yn, xn);    update_mon(monptr);}/* Teleport player to spell casting creature		-RAK-	 */void teleport_to(ny, nx)int ny, nx;{    int dis, ctr, y, x;    dis = 1;    ctr = 0;    do {	do {			   /* bounds check added -CFT */	    y = ny + (randint(2 * dis + 1) - (dis + 1));	    x = nx + (randint(2 * dis + 1) - (dis + 1));	} while (!in_bounds(y, x));	ctr++;	if (ctr > (4 * dis * dis + 4 * dis + 1)) {	    ctr = 0;	    dis++;	}    }    while ((cave[y][x].fval >= MIN_CLOSED_SPACE) || (cave[y][x].cptr >= 2));    move_rec(char_row, char_col, y, x);	darken_player(char_row, char_col);    char_row = y;    char_col = x;    check_view();/* light creatures */    creatures(FALSE);}/* Teleport all creatures in a given direction away	-RAK-	 */int teleport_monster(dir, y, x)int dir, y, x;{    register int        flag, result, dist;    register cave_type *c_ptr;    flag = FALSE;    result = FALSE;    dist = 0;    do {	(void)mmove(dir, &y, &x);	dist++;	c_ptr = &cave[y][x];	if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	else if (c_ptr->cptr > 1) {	    m_list[c_ptr->cptr].csleep = 0;	/* wake it up */	    teleport_away((int)c_ptr->cptr, MAX_SIGHT * 5);	    result = TRUE;	}    }    while (!flag);    return (result);}/* Delete all creatures within max_sight distance	-RAK-	 *//* NOTE : Winning creatures cannot be genocided			 */int mass_genocide(spell)int spell;{    register int        i, result;    register monster_type *m_ptr;    register creature_type *r_ptr;    result = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	r_ptr = &c_list[m_ptr->mptr];	if (((m_ptr->cdis <= MAX_SIGHT) && ((r_ptr->cmove & CM_WIN) == 0) &&	     ((r_ptr->cdefense & UNIQUE) == 0)) || (wizard &&					      (m_ptr->cdis <= MAX_SIGHT))) {	    delete_monster(i);	    if (spell) {		take_hit(randint(3), "the strain of casting Mass Genocide");		prt_chp();		put_qio();#ifdef MSDOS		delay(20* delay_spd);	/* milliseconds */#else		usleep(20000 * delay_spd);	/* useconds */#endif	    }	    result = TRUE;	}    }    return (result);}/* Delete all creatures of a given type from level.	-RAK-	 *//* This does not keep creatures of type from appearing later.	 *//* NOTE : Winning creatures can not be genocided. */int genocide(spell)int spell;{    register int            i, killed;    char                    typ;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val;    killed = FALSE;    if (get_com("Which type of creature do you wish exterminated?", &typ)) {	for (i = mfptr - 1; i >= MIN_MONIX; i--) {	    m_ptr = &m_list[i];	    r_ptr = &c_list[m_ptr->mptr];	    if ((unsigned) typ == c_list[m_ptr->mptr].cchar)		if ((r_ptr->cmove & CM_WIN) == 0) {		    delete_monster(i);		    if (spell) {			take_hit(randint(4), "the strain of casting Genocide");			prt_chp();			put_qio();#ifdef MSDOS			delay(20 * delay_spd);	/* milliseconds */#else			usleep(20000 * delay_spd);	/* useconds */#endif		    }		    killed = TRUE;		} else {		/* genocide is a powerful spell, so we will let the player		 * know the names of the creatures he did not destroy, this		 * message makes no sense otherwise 		 */		    if (r_ptr->cdefense & UNIQUE)			(void)sprintf(out_val, "%s is unaffected.", r_ptr->name);		    else			(void)sprintf(out_val, "The %s is unaffected.", r_ptr->name);		    msg_print(out_val);		}	}    } else	free_turn_flag = TRUE;    return (killed);}/* Change speed of any creature .			-RAK-	 *//* NOTE: cannot slow a winning creature (BALROG)		 */int speed_monsters(spd)int spd;{    register int        i, speed;    register monster_type *m_ptr;    register creature_type *r_ptr;    vtype               out_val, m_name;    speed = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	r_ptr = &c_list[m_ptr->mptr];	monster_name(m_name, m_ptr, r_ptr);	if (!los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx))	/* do nothing */	    ;	else if (spd > 0) {	    m_ptr->cspeed += spd;	    m_ptr->csleep = 0;	    if (m_ptr->ml) {		speed = TRUE;		(void)sprintf(out_val, "%s starts moving faster.", m_name);		msg_print(out_val);	    }	} else if ((r_ptr->level <	    randint((py.misc.lev - 10) < 1 ? 1 : (py.misc.lev - 10)) + 10) &&		   !(r_ptr->cdefense & UNIQUE)) {	    m_ptr->cspeed += spd;	    m_ptr->csleep = 0;	    if (m_ptr->ml) {		(void)sprintf(out_val, "%s starts moving slower.", m_name);		msg_print(out_val);		speed = TRUE;	    }	} else if (m_ptr->ml) {	    (void)sprintf(out_val, "%s is unaffected.", m_name);	    msg_print(out_val);	}    }    return (speed);}/* Sleep any creature .		-RAK-	 */int sleep_monsters2(){    register int        i, sleep;    register monster_type *m_ptr;    register creature_type *r_ptr;    vtype               out_val, m_name;    sleep = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	r_ptr = &c_list[m_ptr->mptr];	monster_name(m_name, m_ptr, r_ptr);	if ((m_ptr->cdis > MAX_SIGHT) ||	    !los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx))	/* do nothing */	    ;	else if ((r_ptr->level >	    randint((py.misc.lev - 10) < 1 ? 1 : (py.misc.lev - 10)) + 10) ||	    (r_ptr->cdefense & UNIQUE) || (r_ptr->cdefense & CHARM_SLEEP)) {	    if (m_ptr->ml) {		if (r_ptr->cdefense & CHARM_SLEEP)		    c_recall[m_ptr->mptr].r_cdefense |= CHARM_SLEEP;		(void)sprintf(out_val, "%s is unaffected.", m_name);		msg_print(out_val);	    }	} else {	    m_ptr->csleep = 500;	    if (m_ptr->ml) {		(void)sprintf(out_val, "%s falls asleep.", m_name);		msg_print(out_val);		sleep = TRUE;	    }	}    }    return (sleep);}/* Polymorph any creature that player can see.  -RAK-   *//* NOTE: cannot polymorph a winning creature (BALROG)            */intmass_poly(){    register int i;    int mass;    register monster_type  *m_ptr;    register creature_type *r_ptr;        mass = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	if (m_ptr->cdis <= MAX_SIGHT) {	    r_ptr = &c_list[m_ptr->mptr];	    if (((r_ptr->cmove & CM_WIN) == 0) && !(r_ptr->cdefense & UNIQUE)) {		mass = poly(i);	    }	}    }    return(mass);}/* Display evil creatures on current panel		-RAK-	 */int detect_evil(){    register int        i, flag;    register monster_type *m_ptr;    flag = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	if (panel_contains((int)m_ptr->fy, (int)m_ptr->fx) &&	    (EVIL & c_list[m_ptr->mptr].cdefense)) {	    m_ptr->ml = TRUE;	/* works correctly even if hallucinating */	    c_print(CC(c_list[m_ptr->mptr].color,(char)c_list[m_ptr->mptr].cchar), (int)m_ptr->fy,		  (int)m_ptr->fx);	    flag = TRUE;	}    }    if (flag) {	msg_print("You sense the presence of evil!");	msg_print(NULL);    /* must unlight every monster just lighted */	creatures(FALSE);    }    return (flag);}/* Change players hit points in some manner		-RAK-	 */int hp_player(num)int num;{    register int          res;    register struct misc *m_ptr;    res = FALSE;    m_ptr = &py.misc;    if (m_ptr->chp < m_ptr->mhp) {	m_ptr->chp += num;	if (m_ptr->chp > m_ptr->mhp) {	    m_ptr->chp = m_ptr->mhp;	    m_ptr->chp_frac = 0;	}	prt_chp();	num = num / 5;	if (num < 3) {	    if (num == 0)		msg_print("You feel a little better.");	    else		msg_print("You feel better.");	} else {	    if (num < 7)		msg_print("You feel much better.");	    else		msg_print("You feel very good.");	}	res = TRUE;    }    return (res);}/* Cure players confusion				-RAK-	 */int cure_confusion(){    register int           cure;    register struct flags *f_ptr;    cure = FALSE;    f_ptr = &py.flags;    if (f_ptr->confused > 1) {	f_ptr->confused = 1;	cure = TRUE;    }    return (cure);}/* Cure players blindness				-RAK-	 */int cure_blindness(){    register int           cure;    register struct flags *f_ptr;    cure = FALSE;    f_ptr = &py.flags;    if (f_ptr->blind > 1) {	f_ptr->blind = 1;	cure = TRUE;    }    return (cure);}/* Cure poisoning					-RAK-	 */int cure_poison(){    register int           cure;    register struct flags *f_ptr;    cure = FALSE;    f_ptr = &py.flags;    if (f_ptr->poisoned > 1) {	f_ptr->poisoned = 1;	cure = TRUE;    }    return (cure);}/* Cure the players fear				-RAK-	 */int remove_fear(){    register int           result;    register struct flags *f_ptr;    result = FALSE;    f_ptr = &py.flags;    if (f_ptr->afraid > 1) {	f_ptr->afraid = 1;	result = TRUE;    }    return (result);}/* This is a fun one.  In a given block, pick some walls and	 *//* turn them into open spots.  Pick some open spots and turn	 *//* them into walls.  An "Earthquake" effect.	       -RAK-   */void earthquake(){    register int        i, j;    register cave_type *c_ptr;    register monster_type *m_ptr;    register creature_type *r_ptr;    int                 kill, damage, tmp, y, x;    vtype               out_val, m_name;    for (i = char_row - 10; i <= char_row + 10; i++)	for (j = char_col - 10; j <= char_col + 10; j++)	    if (((i != char_row) || (j != char_col)) &&		in_bounds(i, j) && (distance(char_row, char_col, i, j)<=10) &&		(randint(8) == 1)) {		c_ptr = &cave[i][j];		if (c_ptr->tptr != 0)		    if (((t_list[c_ptr->tptr].tval >= TV_MIN_WEAR) &&			 (t_list[c_ptr->tptr].tval <= TV_MAX_WEAR) &&			 (t_list[c_ptr->tptr].flags2 & TR_ARTIFACT))			|| (t_list[c_ptr->tptr].tval == TV_UP_STAIR)			|| (t_list[c_ptr->tptr].tval == TV_DOWN_STAIR)			|| (t_list[c_ptr->tptr].tval == TV_STORE_DOOR))			continue;  /* don't touch artifacts or stairs or				    * stores -CFT */		    else			(void)delete_object(i, j);		if (c_ptr->cptr > 1) {		    m_ptr = &m_list[c_ptr->cptr];		    r_ptr = &c_list[m_ptr->mptr];		    if (!(r_ptr->cmove & CM_PHASE) && !(r_ptr->cdefense & BREAK_WALL)) {			if ((movement_rate(c_ptr->cptr) == 0) ||			    (r_ptr->cmove & CM_ATTACK_ONLY))			/* monster can not move to escape the wall */			    kill = TRUE;			else {			/* only kill if there is nowhere for the monster to escape to */			    kill = TRUE;			    for (y = i - 1; y <= i + 1; y++)				for (x = j - 1; x <= j + 1; x++)				    if (cave[y][x].fval >= MIN_CLOSED_SPACE)					kill = FALSE;			}			if (kill)			    damage = 320;			else			    damage = damroll(3 + randint(3), 8+randint(5));			monster_name(m_name, m_ptr, r_ptr);			(void)sprintf(out_val, "%s wails out in pain!", m_name);			msg_print(out_val);			i = mon_take_hit((int)c_ptr->cptr, damage, TRUE);			if (i >= 0) {			    (void)sprintf(out_val, "%s is embedded in the rock.",					  m_name);			    msg_print(out_val);			/* prt_experience(); */			}		    }		}		if ((c_ptr->fval >= MIN_CAVE_WALL) && (c_ptr->fval != BOUNDARY_WALL)) {		    c_ptr->fval = CORR_FLOOR;		    c_ptr->pl = FALSE;		    c_ptr->fm = FALSE;		} else if (c_ptr->fval <= MAX_CAVE_FLOOR) {		    tmp = randint(10);		    if (tmp < 6)			c_ptr->fval = QUARTZ_WALL;		    else if (tmp < 9)			c_ptr->fval = MAGMA_WALL;		    else			c_ptr->fval = GRANITE_WALL;		    c_ptr->fm = FALSE;		}		lite_spot(i, j);	    }}/* Evil creatures don't like this.		       -RAK-   */int protect_evil(){    register int           res;    register struct flags *f_ptr;    f_ptr = &py.flags;    if (f_ptr->protevil == 0)	res = TRUE;    else	res = FALSE;    f_ptr->protevil += randint(25) + 3 * py.misc.lev;    return (res);}/* Create some high quality mush for the player.	-RAK-	    *//* Nope, let's just fill him up and save everybody time... -CWS */void create_food(){     msg_print("You feel full!");	 msg_print(NULL);#if defined(SATISFY_HUNGER)				/* new create food code -CWS */	 py.flags.food = PLAYER_FOOD_MAX;#else     /* add to food timer rather than create mush - cba */     add_food(object_list[OBJ_MUSH].p1);#endif     py.flags.status &= ~(PY_WEAK | PY_HUNGRY);     prt_hunger();}int banish_creature(cflag, dist)int32u cflag;int    dist;{    register int           i;    int                    dispel;    register monster_type *m_ptr;    dispel = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	if ((cflag & c_list[m_ptr->mptr].cdefense) &&	    (m_ptr->cdis <= MAX_SIGHT) &&	    los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx)) {	    c_recall[m_ptr->mptr].r_cdefense |= cflag;	    (void)teleport_away(i, dist);	    dispel = TRUE;	}    }    return (dispel);}int probing(){    register int            i;    int                     probe;    register monster_type  *m_ptr;    register creature_type *r_ptr;    register recall_type   *mp;    vtype                   out_val, m_name;    msg_print("Probing...");    probe = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	r_ptr = &c_list[m_ptr->mptr];	mp = &c_recall[m_ptr->mptr];	if ((m_ptr->cdis <= MAX_SIGHT) &&	    los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx) && 	    (m_ptr->ml)) {	    if (r_ptr->cdefense & UNIQUE)		sprintf(m_name, "%s", r_ptr->name);	    else		sprintf(m_name, "The %s", r_ptr->name);	    sprintf(out_val, "%s has %d hit points.", m_name, m_ptr->hp);	    move_cursor_relative(m_ptr->fy, m_ptr->fx);	    msg_print(out_val);/* let's make probing do good things to the monster memory -CWS */	    mp->r_cdefense = r_ptr->cdefense;	    mp->r_cmove = (r_ptr->cmove & ~CM_TREASURE);	    probe = TRUE;	}    }    if (probe)	msg_print("That's all.");    else	msg_print("You find nothing to probe.");    move_cursor_relative(char_row, char_col);    return (probe);}/* Attempts to destroy a type of creature.  Success depends on	 *//* the creatures level VS. the player's level		 -RAK-	 */int dispel_creature(cflag, damage)int cflag;int damage;{    register int            i;    int                     k, dispel;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    dispel = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	if ((cflag & c_list[m_ptr->mptr].cdefense) &&	    (m_ptr->cdis <= MAX_SIGHT) &&	    los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx)) {	    r_ptr = &c_list[m_ptr->mptr];	    c_recall[m_ptr->mptr].r_cdefense |= cflag;	    monster_name (m_name, m_ptr, r_ptr);	    k = mon_take_hit(i, randint(damage), FALSE);	    if (k >= 0)		(void)sprintf(out_val, "%s dissolves!", m_name);	    else		(void)sprintf(out_val, "%s shudders.", m_name);	    msg_print(out_val);	    dispel = TRUE;	    if (k >= 0)		prt_experience();	}    }    return (dispel);}/* Attempt to turn (confuse) undead creatures.	-RAK-	 */int turn_undead(){    register int            i, turn_und;    register monster_type  *m_ptr;    register creature_type *r_ptr;    vtype                   out_val, m_name;    turn_und = FALSE;    for (i = mfptr - 1; i >= MIN_MONIX; i--) {	m_ptr = &m_list[i];	r_ptr = &c_list[m_ptr->mptr];	if ((UNDEAD & r_ptr->cdefense)	    && (m_ptr->cdis <= MAX_SIGHT)	    && (los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx))) {	    monster_name(m_name, m_ptr, r_ptr);	    if (((py.misc.lev + 1) > r_ptr->level) ||		(randint(5) == 1)) {		if (m_ptr->ml) {		    (void)sprintf(out_val, "%s runs frantically!", m_name);		    msg_print(out_val);		    turn_und = TRUE;		    c_recall[m_ptr->mptr].r_cdefense |= UNDEAD;		}		m_ptr->monfear = randint(py.misc.lev) * 2;	    } else if (m_ptr->ml) {		(void)sprintf(out_val, "%s is unaffected.", m_name);		msg_print(out_val);	    }	}    }    return (turn_und);}/* Leave a glyph of warding. Creatures will not pass over! -RAK- */void warding_glyph(){    register int        i;    register cave_type *c_ptr;    c_ptr = &cave[char_row][char_col];    if (c_ptr->tptr == 0) {	i = popt();	c_ptr->tptr = i;	invcopy(&t_list[i], OBJ_SCARE_MON);    }}/* Lose a strength point.				-RAK-	 */void lose_str(){    if (!py.flags.sustain_str) {	(void)dec_stat(A_STR, 10, FALSE);	msg_print("You feel very weak.");    } else	msg_print("You feel weak for a moment;  it passes.");}/* Lose an intelligence point.				-RAK-	 */void lose_int(){    if (!py.flags.sustain_int) {	(void)dec_stat(A_INT, 10, FALSE);	msg_print("You become very dizzy.");    } else	msg_print("You become dizzy for a moment;  it passes.");}/* Lose a wisdom point.					-RAK-	 */void lose_wis(){    if (!py.flags.sustain_wis) {	(void)dec_stat(A_WIS, 10, FALSE);	msg_print("You feel very naive.");    } else	msg_print("You feel naive for a moment;  it passes.");}/* Lose a dexterity point.				-RAK-	 */void lose_dex(){    if (!py.flags.sustain_dex) {	(void)dec_stat(A_DEX, 10, FALSE);	msg_print("You feel very sore.");    } else	msg_print("You feel sore for a moment;  it passes.");}/* Lose a constitution point.				-RAK-	 */void lose_con(){    if (!py.flags.sustain_con) {	(void)dec_stat(A_CON, 10, FALSE);	msg_print("You feel very sick.");    } else	msg_print("You feel sick for a moment;  it passes.");}/* Lose a charisma point.				-RAK-	 */void lose_chr(){    if (!py.flags.sustain_chr) {	(void)dec_stat(A_CHR, 10, FALSE);	msg_print("Your skin starts to itch.");    } else	msg_print("Your skin starts to itch, but feels better now.");}/* Lose experience					-RAK-	 */void lose_exp(amount)int32 amount;{    register int          i;    register struct misc *m_ptr;    register class_type  *c_ptr;    m_ptr = &py.misc;    if (amount > m_ptr->exp)	m_ptr->exp = 0;    else	m_ptr->exp -= amount;    prt_experience();    i = 0;    while (((player_exp[i] * m_ptr->expfact / 100) <= m_ptr->exp)	   && (i < MAX_PLAYER_LEVEL))	i++;/* increment i once more, because level 1 exp is stored in player_exp[0] */    i++;    if (i > MAX_PLAYER_LEVEL)	i = MAX_PLAYER_LEVEL;    if (m_ptr->lev != i) {	m_ptr->lev = i;	calc_hitpoints();	c_ptr = &class[m_ptr->pclass];	if (c_ptr->spell == MAGE) {	    calc_spells(A_INT);	    calc_mana(A_INT);	} else if (c_ptr->spell == PRIEST) {	    calc_spells(A_WIS);	    calc_mana(A_WIS);	}	prt_level();	prt_title();    }}/* Slow Poison						-RAK-	 */int slow_poison(){    register int           slow;    register struct flags *f_ptr;    slow = FALSE;    f_ptr = &py.flags;    if (f_ptr->poisoned > 0) {	f_ptr->poisoned = f_ptr->poisoned / 2;	if (f_ptr->poisoned < 1)	    f_ptr->poisoned = 1;	slow = TRUE;	msg_print("The effect of the poison has been reduced.");    }    return (slow);}/* Bless						-RAK-	 */void bless(amount)int amount;{    py.flags.blessed += amount;}/* Detect Invisible for period of time			-RAK-	 */void detect_inv2(amount)int amount;{    py.flags.detect_inv += amount;}static void replace_spot(y, x, typ)int y, x, typ;{    register cave_type *c_ptr;    c_ptr = &cave[y][x];    switch (typ) {      case 1:      case 2:      case 3:	c_ptr->fval = CORR_FLOOR;	break;      case 4:      case 7:      case 10:	c_ptr->fval = GRANITE_WALL;	break;      case 5:      case 8:      case 11:	c_ptr->fval = MAGMA_WALL;	break;      case 6:      case 9:      case 12:	c_ptr->fval = QUARTZ_WALL;	break;    }    c_ptr->pl = FALSE;    c_ptr->fm = FALSE;    c_ptr->lr = FALSE;		   /* this is no longer part of a room */    if (c_ptr->tptr != 0)	(void)delete_object(y, x);    if (c_ptr->cptr > 1)	delete_monster((int)c_ptr->cptr);}/* The spell of destruction.				-RAK-	 *//* NOTE : Winning creatures that are deleted will be considered	 *//* as teleporting to another level.  This will NOT win the *//* game.						       */void destroy_area(y, x)register int y, x;{    register int i, j, k;    msg_print("There is a searing blast of light!");    if (!py.flags.blindness_resist && !py.flags.light_resist)	py.flags.blind += 10 + randint(10);    if (dun_level > 0) {	for (i = (y - 15); i <= (y + 15); i++)	    for (j = (x - 15); j <= (x + 15); j++)		if (in_bounds(i, j) && (cave[i][j].fval != BOUNDARY_WALL) &&		    ((cave[i][j].tptr == 0) ||		     ((t_list[cave[i][j].tptr].tval != TV_UP_STAIR) &&		      (t_list[cave[i][j].tptr].tval != TV_DOWN_STAIR) &&		      (!(t_list[cave[i][j].tptr].flags2 & TR_ARTIFACT))))) {	/* DGK */		    k = distance(i, j, y, x);		    if (k == 0)	   /* player's spot... */			replace_spot(i, j, 1);	/* clear player's spot...						 * from um55 -CFT */		    else if (k < 13)			replace_spot(i, j, randint(6));		    else if (k < 16)			replace_spot(i, j, randint(9));		}    }    /* We need to redraw the screen. -DGK */    if (py.flags.blindness_resist || py.flags.light_resist) {	draw_cave();	creatures(FALSE);	   /* draw monsters */    }}#if 0voidenchant_armor(){    int k = 0, l = 0, i, chosen, first;    int which[INVEN_ARRAY_SIZE];/* enchant cursed items first without asking */        if (TR_CURSED & inventory[INVEN_BODY].flags)	l = INVEN_BODY;    else if (TR_CURSED & inventory[INVEN_ARM].flags)	l = INVEN_ARM;    else if (TR_CURSED & inventory[INVEN_OUTER].flags)	l = INVEN_OUTER;    else if (TR_CURSED & inventory[INVEN_HEAD].flags)	l = INVEN_HEAD;    else if (TR_CURSED & inventory[INVEN_HANDS].flags)	l = INVEN_HANDS;    else if (TR_CURSED & inventory[INVEN_FEET].flags)	l = INVEN_FEET;    if (!l) {                /* if no cursed items, let player select which */	int num = 0, flag = FALSE;	for (i = INVEN_WIELD; i < INVEN_ARRAY_SIZE; i++)	    which[i] = FALSE;	if (inventory[INVEN_BODY].tval != TV_NOTHING)	    which[INVEN_BODY] = TRUE;	if (inventory[INVEN_ARM].tval != TV_NOTHING)	    which[INVEN_ARM] = TRUE;	if (inventory[INVEN_OUTER].tval != TV_NOTHING)	    which[INVEN_OUTER] = TRUE;	if (inventory[INVEN_HANDS].tval != TV_NOTHING)	    which[INVEN_HANDS] = TRUE;	if (inventory[INVEN_HEAD].tval != TV_NOTHING)	    which[INVEN_HEAD] = TRUE;	if (inventory[INVEN_FEET].tval != TV_NOTHING)	    which[INVEN_FEET] = TRUE;	for (i = INVEN_WIELD; i < INVEN_ARRAY_SIZE; i++)	    if (which[i]) {		num++;		if (!flag)		    first = i;		flag = TRUE;	    }	if (!flag)	    return;	show_equip(FALSE, 0);	    }	    if (l > 0) {	char                out_val[100], tmp_str[100];		I_ptr = &inventory[l];	objdes(tmp_str, i_ptr, FALSE);	sprintf(out_val, "Your %s glows faintly!", tmp_str);	msg_print(out_val);	if (!enchant(i_ptr, randint(3)+1, ENCH_TOAC))	    msg_print("The enchantment fails.");    }}#endif/* Revamped!  Now takes item pointer, number of times to try enchanting, * and a flag of what to try enchanting.  Artifacts resist enchantment * some of the time, and successful enchantment to at least +0 might * break a curse on the item.  -CFT *//* Enchants a plus onto an item.                        -RAK-   */intenchant(i_ptr, n, eflag)inven_type *i_ptr;int n;int8u eflag;{    int chance, res = FALSE, i, a = i_ptr->flags2 & TR_ARTIFACT;    static int table[13] = {  10,  50, 100, 200, 300, 400,                           500, 700, 950, 990, 992, 995, 997 };    for(i=0; i<n; i++){	chance = 0;	if (eflag & ENCH_TOHIT) {	    if (i_ptr->tohit < 1) chance = 0;	    else if (i_ptr->tohit > 13) chance = 1000;	    else chance = table[i_ptr->tohit-1];	    if ((randint(1000)>chance) && (!a || randint(7)>3)) {		i_ptr->tohit++;		res = TRUE;		if ((i_ptr->tohit >= 0) && (randint(4)==1) && /* only when you get */		    (i_ptr->flags & TR_CURSED)) { /*  it above -1 -CFT */		    msg_print("The curse is broken! ");		    i_ptr->flags &= ~TR_CURSED;		    i_ptr->ident &= ~ID_DAMD;		}	    }	}	if (eflag & ENCH_TODAM) {	    if (i_ptr->todam < 1) chance = 0;	    else if (i_ptr->todam > 13) chance = 1000;	    else chance = table[i_ptr->todam-1];	    if ((randint(1000)>chance) && (!a || randint(7)>3)) {		i_ptr->todam++;		res = TRUE;		if ((i_ptr->todam >= 0) && (randint(4)==1) && /* only when you get */		    (i_ptr->flags & TR_CURSED)) { /*  it above -1 -CFT */		    msg_print("The curse is broken! ");		    i_ptr->flags &= ~TR_CURSED;		    i_ptr->ident &= ~ID_DAMD;		}	    }	}	if (eflag & ENCH_TOAC) {	    if (i_ptr->toac < 1) chance = 0;	    else if (i_ptr->toac > 13) chance = 1000;	    else chance = table[i_ptr->toac-1];	    if ((randint(1000)>chance) && (!a || randint(7)>3)) {		i_ptr->toac++;		res = TRUE;		if ((i_ptr->toac >= 0) && (randint(4)==1) && /* only when you get */		    (i_ptr->flags & TR_CURSED)) { /*  it above -1 -CFT */		    msg_print("The curse is broken! ");		    i_ptr->flags &= ~TR_CURSED;		    i_ptr->ident &= ~ID_DAMD;		}	    }	}    } /* for loop */    if (res) calc_bonuses ();    return(res);}const char *pain_message(monptr, dam)int monptr, dam;{    register monster_type *m_ptr;    creature_type      *c_ptr;    int                 percentage, oldhp, newhp;    if (dam == 0)	return "%s is unharmed.";  /* avoid potential div by 0 */    m_ptr = &m_list[monptr];    c_ptr = &c_list[m_ptr->mptr];#ifdef MSDOS			   /* more fix -CFT */    newhp = (int32) (m_ptr->hp);    oldhp = newhp + (int32) dam;#else    newhp = m_ptr->hp;    oldhp = newhp + dam;#endif    percentage = (newhp * 100L) / oldhp;    if ((c_ptr->cchar == 'j') ||   /* Non-verbal creatures like molds */	(c_ptr->cchar == 'Q') || (c_ptr->cchar == 'v') ||     (c_ptr->cchar == 'm') || ((c_ptr->cchar == 'e') && stricmp(c_ptr->name,							     "Beholder"))) {	if (percentage > 95)	    return "%s barely notices.";	if (percentage > 75)	    return "%s flinches.";	if (percentage > 50)	    return "%s squelches.";#if 1	if (percentage > 35)		return "%s quivers in pain.";#else	if (percentage > 35) {	    if (randint(4) == 1) /* thanks to dbd@panacea.phys.utk.edu -CWS */		return "%s quivers in pain.";	    else		return "%s imitates Bill Cosby in pain.";	}#endif	if (percentage > 20)	    return "%s writhes about.";	if (percentage > 10)	    return "%s writhes in agony.";	return "%s jerks limply.";    } else if (c_ptr->cchar == 'C' || c_ptr->cchar == 'Z') {	if (percentage > 95)	    return "%s shrugs off the attack.";	if (percentage > 75)	    return "%s snarls with pain.";	if (percentage > 50)	    return "%s yelps in pain.";	if (percentage > 35)	    return "%s howls in pain.";	if (percentage > 20)	    return "%s howls in agony.";	if (percentage > 10)	    return "%s writhes in agony.";	return "%s yelps feebly.";    } else if (c_ptr->cchar == 'K' || c_ptr->cchar == 'c' || c_ptr->cchar == 'a' ||	c_ptr->cchar == 'U' || c_ptr->cchar == 'q' || c_ptr->cchar == 'R' ||	c_ptr->cchar == 'X' || c_ptr->cchar == 'b' || c_ptr->cchar == 'F' ||	c_ptr->cchar == 'J' || c_ptr->cchar == 'l' || c_ptr->cchar == 'r' ||	c_ptr->cchar == 's' || c_ptr->cchar == 'S' || c_ptr->cchar == 't') {	if (percentage > 95)	    return "%s ignores the attack.";	if (percentage > 75)	    return "%s grunts with pain.";	if (percentage > 50)	    return "%s squeals in pain.";	if (percentage > 35)	    return "%s shrieks in pain.";	if (percentage > 20)	    return "%s shrieks in agony.";	if (percentage > 10)	    return "%s writhes in agony.";	return "%s cries out feebly.";    } else {	if (percentage > 95)	    return "%s shrugs off the attack.";	if (percentage > 75)	    return "%s grunts with pain.";	if (percentage > 50)	    return "%s cries out in pain.";	if (percentage > 35)	    return "%s screams in pain.";	if (percentage > 20)	    return "%s screams in agony.";	if (percentage > 10)	    return "%s writhes in agony.";	return "%s cries out feebly.";    }}/* Removes curses from items in inventory		-RAK-	 */int remove_curse(){    register int         i, result;    register inven_type *i_ptr;    result = FALSE;    for (i = INVEN_WIELD; i <= INVEN_OUTER; i++) {	i_ptr = &inventory[i];	if ((TR_CURSED & i_ptr->flags) &&	    (i_ptr->name2 != SN_MORGUL) &&	    (i_ptr->name2 != SN_CALRIS) &&	    (i_ptr->name2 != SN_MORMEGIL)) {	    if (!(!stricmp(object_list[i_ptr->index].name, "Power") &&		  (i_ptr->tval == TV_RING))) {		i_ptr->flags &= ~TR_CURSED;		i_ptr->ident &= ~ID_DAMD;	/* DGK */		i_ptr->inscrip[0] = '\0';		calc_bonuses();		changeinven();		result = TRUE;	    }	}    }    return (result);}int remove_all_curse(){    register int         i, result;    register inven_type *i_ptr;    result = FALSE;    for (i = INVEN_WIELD; i <= INVEN_OUTER; i++) {	i_ptr = &inventory[i];	if (TR_CURSED & i_ptr->flags) {	    if (!(!stricmp(object_list[i_ptr->index].name, "Power") &&		  (i_ptr->tval == TV_RING))) {		i_ptr->flags &= ~TR_CURSED;		i_ptr->ident &= ~ID_DAMD;	/* DGK */		calc_bonuses();		i_ptr->inscrip[0] = '\0';		changeinven();		result = TRUE;	    } else {		msg_print("The One Ring resists all attempts to remove it!");	    }	}    }    return (result);}/* Restores any drained experience			-RAK-	 */int restore_level(){    register int          restore;    register struct misc *m_ptr;    restore = FALSE;    m_ptr = &py.misc;    if (m_ptr->max_exp > m_ptr->exp) {	restore = TRUE;	msg_print("You feel your life energies returning.");    /* this while loop is not redundant, ptr_exp may reduce the exp level */	while (m_ptr->exp < m_ptr->max_exp) {	    m_ptr->exp = m_ptr->max_exp;	    prt_experience();	}    }    return (restore);}/* this fn only exists to avoid duplicating this code in the selfknowledge fn. -CFT */static void pause_if_screen_full(i, j)int *i;int  j;{    int t;    if (*i == 22) {		   /* is screen full? */	prt("-- more --", *i, j);	inkey();	for (t = 2; t < 23; t++)	    erase_line(t, j);	   /* don't forget to erase extra */	prt("Your Attributes: (continued)", 1, j + 5);	*i = 2;    }}/* self-knowledge... idea from nethack.  Useful for determining powers and * resistences of items.  It saves the screen, clears it, then starts listing * attributes, a screenful at a time.  (There are a LOT of attributes to * list.  It will probably take 2 or 3 screens for a powerful character whose * using several artifacts...) -CFT  */void self_knowledge(){    int    i, j;    int32u f = 0L, f2 = 0L;    for (i = INVEN_WIELD; i <= INVEN_LIGHT; i++) {	/* get flags from items */	if (inventory[i].tval != TV_NOTHING) {	    if (inventory[i].p1 < 0) /* don't adjust TR_STATS if p1 is negative -CWS */		f |= (inventory[i].flags & ~(TR_STATS | TR_SEARCH | TR_STEALTH) );	    else		f |= inventory[i].flags;	    f2 |= inventory[i].flags2;	}    }    save_screen();/* map starts at 13, but I want a couple of spaces. * This means must start by erasing map... */    j = 15;    for (i = 1; i < 23; i++)	erase_line(i, j - 2);	   /* erase a couple of spaces to left */    i = 1;    prt("Your Attributes:", i++, j + 5);    if (py.flags.blind > 0)	prt("You cannot see.", i++, j);    if (py.flags.confused > 0)	prt("You are confused.", i++, j);    if (py.flags.afraid > 0)	prt("You are terrified.", i++, j);    if (py.flags.cut > 0)	prt("You are bleeding.", i++, j);    if (py.flags.stun > 0)	prt("You are stunned and reeling.", i++, j);    if (py.flags.poisoned > 0)	prt("You are poisoned.", i++, j);    if (py.flags.image > 0)	prt("You are hallucinating.", i++, j);    if (py.flags.aggravate)	prt("You aggravate monsters.", i++, j);    if (py.flags.teleport)	prt("Your position is very uncertain.", i++, j);    if (py.flags.blessed > 0)	prt("You feel rightous.", i++, j);    if (py.flags.hero > 0)	prt("You feel heroic.", i++, j);    if (py.flags.shero > 0)	prt("You are in a battle rage.", i++, j);    if (py.flags.protevil > 0)	prt("You are protected from evil.", i++, j);    if (py.flags.shield > 0)	prt("You are protected by a mystic shield.", i++, j);    if (py.flags.invuln > 0)	prt("You are temporarily invulnerable.", i++, j);    if (py.flags.confuse_monster)	prt("Your hands are glowing dull red.", i++, j);    if (py.flags.new_spells > 0)	prt("You can learn some more spells.", i++, j);    if (py.flags.word_recall > 0)	prt("You will soon be recalled.", i++, j);    if (f & TR_STEALTH)	prt("You are magically stealthy.", i++, j);    if (f & TR_SEARCH) {	prt("You are magically perceptive.", i++, j);	pause_if_screen_full(&i, j);    }    if ((py.flags.see_infra) || (py.flags.tim_infra)) {	prt("Your eyes are sensitive to infrared light.", i++, j);	pause_if_screen_full(&i, j);    }    if ((py.flags.see_inv) || (py.flags.detect_inv)) {	prt("You can see invisible creatures.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.ffall) {	prt("You land gently.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.free_act) {	prt("You have free action.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.regenerate) {	prt("You regenerate quickly.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.slow_digest) {	prt("Your appetite is small.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.telepathy) {	prt("You have ESP.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.hold_life) {	prt("You have a firm hold on your life force.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.light) {	prt("You are carrying a permanent light.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.fear_resist) {	prt("You are completely fearless.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.blindness_resist) {	prt("Your eyes are resistant to blindness.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.fire_im) {	prt("You are completely immune to fire.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.fire_resist) && (py.flags.resist_heat)) {	prt("You resist fire exceptionally well.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.fire_resist) || (py.flags.resist_heat)) {	prt("You are resistant to fire.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.cold_im) {	prt("You are completely immune to cold.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.cold_resist) && (py.flags.resist_cold)) {	prt("You resist cold exceptionally well.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.cold_resist) || (py.flags.resist_cold)) {	prt("You are resistant to cold.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.acid_im) {	prt("You are completely immune to acid.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.acid_resist) && (py.flags.resist_acid)) {	prt("You resist acid exceptionally well.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.acid_resist) || (py.flags.resist_acid)) {	prt("You are resistant to acid.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.poison_im) {	prt("You are completely immune to poison.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.poison_resist) && (py.flags.resist_poison)) {	prt("You resist poison exceptionally well.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.poison_resist) || (py.flags.resist_poison)) {	prt("You are resistant to poison.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.light_im) {	prt("You are completely immune to lightning.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.lght_resist) && (py.flags.resist_light)) {	prt("You resist lightning exceptionally well.", i++, j);	pause_if_screen_full(&i, j);    } else if ((py.flags.lght_resist) || (py.flags.resist_light)) {	prt("You are resistant to lightning.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.light_resist) {	prt("You are resistant to bright light.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.dark_resist) {	prt("You are resistant to darkness.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.confusion_resist) {	prt("You are resistant to confusion.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.sound_resist) {	prt("You are resistant to sonic attacks.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.disenchant_resist) {	prt("You are resistant to disenchantment.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.chaos_resist) {	prt("You are resistant to chaos.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.shards_resist) {	prt("You are resistant to blasts of shards.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.nexus_resist) {	prt("You are resistant to nexus attacks.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.nether_resist) {	prt("You are resistant to nether forces.", i++, j);	pause_if_screen_full(&i, j);    }#if 0/* Are these needed?  The player can see this...  For now, in here for * completeness... -CFT  */    if (f & TR_STR) {	prt("You are magically strong.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_INT) {	prt("You are magically intelligent.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_WIS) {	prt("You are magically wise.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_DEX) {	prt("You are magically agile.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_CON) {	prt("You are magically tough.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_CHR) {	prt("You are magically popular.", i++, j);	pause_if_screen_full(&i, j);    }#endif    if (py.flags.sustain_str) {	prt("You will not become weaker.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.sustain_int) {	prt("You will not become dumber.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.sustain_wis) {	prt("You will not become less wise.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.sustain_con) {	prt("You will not become out of shape.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.sustain_dex) {	prt("You will not become clumsy.", i++, j);	pause_if_screen_full(&i, j);    }    if (py.flags.sustain_chr) {	prt("You will not become less popular.", i++, j);	pause_if_screen_full(&i, j);    }    if (inventory[INVEN_LEFT].flags2 & TR_ATTACK_SPD ||	inventory[INVEN_RIGHT].flags2 & TR_ATTACK_SPD) {	prt("You can strike at your foes with uncommon speed.", i++, j);	pause_if_screen_full(&i, j);    }/* this IS a bit redundant, but it prevents flags from other items from * affecting the weapon stats... -CFT */    if (inventory[INVEN_WIELD].tval != TV_NOTHING) {	f = inventory[INVEN_WIELD].flags;	f2 = inventory[INVEN_WIELD].flags2;    } else {	f = 0L;	f2 = 0L;    }    if (f & TR_CURSED) {	if (inventory[INVEN_WIELD].name2 == SN_MORGUL)	    prt("Your weapon is truly foul.", i++, j);	else if (inventory[INVEN_WIELD].name2 == SN_CALRIS)	    prt("Your bastard sword is wickedly accursed.", i++, j);	else if (inventory[INVEN_WIELD].name2 == SN_MORMEGIL)	    prt("Your two-handed sword radiates an aura of unspeakable evil.", i++, j);	else	    prt("Your weapon is accursed.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_TUNNEL) {	prt("Your weapon is an effective digging tool.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_BLESS_BLADE) {	prt("Your weapon has been blessed by the gods.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_ATTACK_SPD) {	prt("Your weapon strikes with uncommon speed.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_SLAY_ORC) {	prt("Your weapon is especially deadly against orcs.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_SLAY_TROLL) {	prt("Your weapon is especially deadly against trolls.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_SLAY_GIANT) {	prt("Your weapon is especially deadly against giants.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_SLAY_ANIMAL) {	prt("Your weapon is especially deadly against natural creatures.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_SLAY_X_DRAGON) {	prt("Your weapon is a great bane of dragons.", i++, j);	pause_if_screen_full(&i, j);    } else if (f & TR_SLAY_DRAGON) {	prt("Your weapon is especially deadly against dragons.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_SLAY_DEMON) {	prt("Your weapon strikes at demons with holy wrath.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_SLAY_UNDEAD) {	prt("Your weapon strikes at undead with holy wrath.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_SLAY_EVIL) {	prt("Your weapon fights against evil with holy fury.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_FROST_BRAND) {	prt("Your frigid weapon freezes your foes.", i++, j);	pause_if_screen_full(&i, j);    }    if (f & TR_FLAME_TONGUE) {	prt("Your flaming weapon burns your foes.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_LIGHTNING) {	prt("Your weapon electrocutes your foes.", i++, j);	pause_if_screen_full(&i, j);    }    if (f2 & TR_IMPACT)	prt("The unbelievable impact of your weapon can cause earthquakes.", i++, j);    pause_line(i);    restore_screen();}#define NO_RES 0#define SOME_RES 1#define RESIST 2#define IMMUNE 3#define SUSCEPT 4#define CHANGED 5#define CONFUSED 6#define MORE_CONF 7#define DAZED 8#define MORE_DAZED 16#define DEAD 32/* This function will process a bolt/ball/breath spell hitting a monster. * It checks for resistances, and reduces damage accordingly, and also * adds in what "special effects" apply to the monsters.  'rad' is used to * indicate the distance from "ground 0" for ball spells.  For bolts, rad * should be a 0 (this flags off some of the messages).  dam is changed * to reflect resistances and range. -CFT */voidspell_hit_monster(m_ptr, typ, dam, rad, y, x, by_player)monster_type *m_ptr;int           typ, *dam, rad, *y, *x, by_player;{    register creature_type *r_ptr;    int blind = (py.flags.status & PY_BLIND) ? 1 : 0;    int res;			/* controls messages, using above #defines -CFT */    vtype cdesc, outval;    if (rad)	*dam /= rad;		/* adjust damage for range... */    *y = m_ptr->fy;		/* these only change if mon gets teleported */    *x = m_ptr->fx;     r_ptr = &c_list[m_ptr->mptr];    if (m_ptr->ml){	if (r_ptr->cdefense & UNIQUE)	    sprintf(cdesc, "%s ", r_ptr->name);	else	    sprintf(cdesc, "The %s ", r_ptr->name);    }    else	strcpy(cdesc, "It ");    res = NO_RES;		/* assume until we know different -CFT */    switch ( typ ){		/* check for resists... */      case GF_MAGIC_MISSILE:	/* pure damage, no resist possible */	break;      case GF_LIGHTNING:	if (r_ptr->cdefense & IM_LIGHTNING) {	    res = RESIST;	    *dam /= 9;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= IM_LIGHTNING;        }	break;      case GF_POISON_GAS:	if (r_ptr->cdefense & IM_POISON) {	    res = RESIST;	    *dam /= 9;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= IM_POISON;        }	break;      case GF_ACID:	if (r_ptr->cdefense & IM_ACID) {	    res = RESIST;	    *dam /= 9;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= IM_ACID;        }	break;      case GF_FROST:	if (r_ptr->cdefense & IM_FROST) {	    res = RESIST;	    *dam /= 9;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= IM_FROST;        }	break;      case GF_FIRE:	if (r_ptr->cdefense & IM_FIRE) {	    res = RESIST;	    *dam /= 9;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= IM_FIRE;        }	break;      case GF_HOLY_ORB:	if (r_ptr->cdefense & EVIL) {	    *dam *= 2;	    res = SUSCEPT;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= EVIL;        }	break;      case GF_ARROW:		/* for now, no defense... maybe it should have a				   chance of missing? -CFT */	break;      case GF_PLASMA:		/* maybe IM_LIGHTNING (ball lightning is supposed				   to be plasma) or IM_FIRE (since it's hot)? -CFT */	if (!strncmp("Plasma", r_ptr->name, 6) ||	    (r_ptr->spells3 & BREATH_PL)){ /* if is a "plasma" monster,					      or can breathe plasma, then					      we assume it should be immune.					      plasma bolts don't count, since					      mage-types could have them, and					      not deserve plasma-resist -CFT */	    res = RESIST;	    *dam *= 3;		/* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */	}	break;      case GF_NETHER:		/* I assume nether is an evil, necromantic force,				   so it doesn't hurt undead, and hurts evil less -CFT */	if (r_ptr->cdefense & UNDEAD) {	    res = IMMUNE;	    *dam = 0;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= UNDEAD;        }	else if (r_ptr->spells2 & BREATH_LD) { /* if can breath nether, should get						  good resist to damage -CFT */	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */	}	else if (r_ptr->cdefense & EVIL) {	    *dam /= 2;	/* evil takes *2 for holy, so /2 for this... -CFT */	    res = SOME_RES;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= EVIL;        }	break;      case GF_WATER:	/* water elementals should resist.  anyone else? -CFT */	if ((r_ptr->cchar == 'E') && (r_ptr->name[0] == 'W')){	    res = IMMUNE;	    *dam = 0; /* water spirit, water ele, and Waldern -CFT */        }	break;      case GF_CHAOS:	if (r_ptr->spells2 & BREATH_CH){ /* assume anything that breathes					    choas is chaotic enough to deserve resistance... -CFT */	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	if ((*dam <= m_ptr->hp) && /* don't bother if it's gonna die */	    !(r_ptr->spells2 & BREATH_CH) &&	    !(r_ptr->cdefense & UNIQUE) &&	    (randint(90) > r_ptr->level)) { /* then we'll polymorph it -CFT */	    res = CHANGED;	    if (poly(cave[*y][*x].cptr))		*dam = 0; /* new monster was not hit by choas breath.  This also			     makes things easier to handle */	} /* end of choas-poly.  If was poly-ed don't bother confuse... it's	     too hectic to keep track of... -CFT */	else if (!(r_ptr->cdefense & CHARM_SLEEP) &&		 !(r_ptr->spells2 & BREATH_CH) && /* choatics hard to confuse */		 !(r_ptr->spells2 & BREATH_CO)){   /* so are bronze dragons */	    if (m_ptr->confused > 0) { 		res = MORE_CONF;		if (m_ptr->confused < 240){ /* make sure not to overflow -CFT */		    m_ptr->confused += 7/(rad>0 ? rad : 1);		}	    }	    else {		res = CONFUSED;		m_ptr->confused = (randint(11)+5)/(rad>0 ? rad : 1);	    }	}	break;      case GF_SHARDS:	if (r_ptr->spells2 & BREATH_SH){ /* shard breathers resist -CFT */	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	break;      case GF_SOUND:      if (r_ptr->spells2 & BREATH_SD){ /* ditto for sound -CFT */	  res = RESIST;	  *dam *= 2;	  *dam /= (randint(6)+6);      }	if ((*dam <= m_ptr->hp) && /* don't bother if it's dead */	    !(r_ptr->spells2 & BREATH_SD) &&	    !(r_ptr->spells3 & BREATH_WA)) { /* sound and impact breathers	  					should not stun -CFT */	    if (m_ptr->confused > 0) { 		res = MORE_DAZED;		if (m_ptr->confused < 220){ /* make sure not to overflow -CFT */		    m_ptr->confused += (randint(5)*2)/(rad>0 ? rad : 1);		}	    }	    else {		res = DAZED;		m_ptr->confused = (randint(15)+10)/(rad>0 ? rad : 1);	    }  	}	break;      case GF_CONFUSION:	if (r_ptr->spells2 & BREATH_CO){ 	    res = RESIST;	    *dam *= 2;	    *dam /= (randint(6)+6);        }	else if (r_ptr->cdefense & CHARM_SLEEP){	    res = SOME_RES;	    *dam /= 2; /* only some resist, but they also avoid confuse -CFT */        }	if ((*dam <= m_ptr->hp) && /* don't bother if it's dead */	    !(r_ptr->cdefense & CHARM_SLEEP) &&	    !(r_ptr->spells2 & BREATH_CH) && /* choatics hard to confuse */	    !(r_ptr->spells2 & BREATH_CO)) {  /* so are bronze dragons */	    if (m_ptr->confused > 0) { 		res = MORE_CONF;		if (m_ptr->confused < 240){ /* make sure not to overflow -CFT */		    m_ptr->confused += 7/(rad>0 ? rad : 1);		}	    }	    else {		res = CONFUSED;		m_ptr->confused = (randint(11)+5)/(rad>0 ? rad : 1);	    }	}        break;      case GF_DISENCHANT:	if ((r_ptr->spells2 & BREATH_DI) ||	    !strncmp("Disen", r_ptr->name, 5)) {	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	break;      case GF_NEXUS:	if ((r_ptr->spells2 & BREATH_NE) ||	    !strncmp("Nexus", r_ptr->name, 5)) {	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	break;      case GF_FORCE:	if (r_ptr->spells3 & BREATH_WA){ /* breath ele force resists					    ele force -CFT */	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	if ((*dam <= m_ptr->hp) &&	    !(r_ptr->spells2 & BREATH_SD) &&	    !(r_ptr->spells3 & BREATH_WA)){ /* sound and impact breathers					       should not stun -CFT */	    if (m_ptr->confused > 0) { 		res = MORE_DAZED;		if (m_ptr->confused < 220){ /* make sure not to overflow -CFT */		    m_ptr->confused += (randint(5)+1)/(rad>0 ? rad : 1);		}	    }	    else {		res = DAZED;		m_ptr->confused = randint(15)/(rad>0 ? rad : 1);	    }	}	break;      case GF_INERTIA:	if (r_ptr->spells3 & BREATH_SL){ /* if can breath inertia, then					    resist it. */	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	break;      case GF_LIGHT:	if (r_ptr->spells3 & BREATH_LT){ /* breathe light to res light */	    res = RESIST;	    *dam *= 2;	    *dam /= (randint(6)+6);        }	else if (r_ptr->cdefense & HURT_LIGHT){	    res = SUSCEPT;	    *dam *= 2; /* hurt bad by light */        }	else if (r_ptr->spells3 & BREATH_DA){ /* breathe dark gets hurt */	    res = SUSCEPT;	    *dam = (*dam * 3)/2;        }	break;      case GF_DARK:	if (r_ptr->spells2 & BREATH_DA){ /* shard breathers resist -CFT */	    res = RESIST;	    *dam *= 2;	    *dam /= (randint(6)+6);        }	else if (r_ptr->cdefense & HURT_LIGHT){	    res = SOME_RES;	    *dam /= 2; /* hurt bad by light, so not hurt bad by dark */        }	else if (r_ptr->spells3 & BREATH_LT){ /* breathe light gets hurt */	    res = SUSCEPT;	    *dam = (*dam * 3)/2;        }	break;      case GF_TIME:	if (r_ptr->spells3 & BREATH_TI){ /* time breathers resist -CFT */	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	break;      case GF_GRAVITY:	if (r_ptr->spells3 & BREATH_GR){ /* breathers resist -CFT */	    res = RESIST;	    *dam *= 3;  /* these 2 lines give avg dam of .33, ranging */	    *dam /= (randint(6)+6); /* from .427 to .25 -CFT */        }	else {	    if (*dam <= m_ptr->hp) {		teleport_away(cave[m_ptr->fy][m_ptr->fx].cptr, 5);		*y = m_ptr->fy; /* teleported, so let outside world know monster moved! */		*x = m_ptr->fx; 	    }        }	break;      case GF_MANA: /* raw blast of power. no way to resist, is there? */	break;      case GF_METEOR: /* GF_METEOR is basically a powerful magic-missile			 ball spell.  I only made it a different type			 so I could make it a different color -CFT */	break;      case GF_ICE: /* ice is basically frost + cuts + stun -CFT */	if (r_ptr->cdefense & IM_FROST) {	    res = RESIST;	    *dam /= 9;	    if (m_ptr->ml)		c_recall[m_ptr->mptr].r_cdefense |= IM_FROST;        }	if ((*dam <= m_ptr->hp) &&	    !(r_ptr->spells2 & BREATH_SD) &&	    !(r_ptr->spells3 & BREATH_WA)){  /* sound and impact breathers	  					should not stun -CFT */	    if (m_ptr->confused > 0) { 		res += MORE_DAZED;		if (m_ptr->confused < 220){ /* make sure not to overflow -CFT */		    m_ptr->confused += (randint(5)+1)/(rad>0 ? rad : 1);		}	    }	    else {		res += DAZED;		m_ptr->confused = randint(15)/(rad>0 ? rad : 1);	    }	}	break;      default:	msg_print("Unknown typ in spell_hit_monster.  This may mean trouble.");    } /* end switch for saving throws and extra effects */        if (res == CHANGED)	sprintf(outval, "%schanges!",cdesc);    else if ((*dam > m_ptr->hp) &&	     (by_player || !(c_list[m_ptr->mptr].cdefense & UNIQUE))) {	res = DEAD;	if ((c_list[m_ptr->mptr].cdefense & (DEMON|UNDEAD|MINDLESS)) ||	    (c_list[m_ptr->mptr].cchar == 'E') ||	    (c_list[m_ptr->mptr].cchar == 'v') ||	    (c_list[m_ptr->mptr].cchar == 'g') ||	    (c_list[m_ptr->mptr].cchar == 'X'))	    sprintf(outval, "%sis destroyed.", cdesc);	else	    sprintf(outval, "%sdies.", cdesc);    }    else switch (res) {      case NO_RES:	sprintf(outval, "%sis hit.",cdesc);	break;      case SOME_RES:	sprintf(outval, "%sresists somewhat.",cdesc);	break;      case RESIST:	sprintf(outval, "%sresists.",cdesc);	break;      case IMMUNE:	sprintf(outval, "%sis immune.",cdesc);	break;      case SUSCEPT:	sprintf(outval, "%sis hit hard.",cdesc);	break;      case CONFUSED:	sprintf(outval, "%sis confused.",cdesc);	break;      case MORE_CONF:	sprintf(outval, "%sis more confused.",cdesc);	break;      case DAZED:	sprintf(outval, "%sis dazed.",cdesc);	break;      case MORE_DAZED:	sprintf(outval, "%sis more dazed.",cdesc);	break;      case (DAZED+RESIST):	  sprintf(outval, "%sresists, but is dazed anyway.",cdesc);	break;      case (MORE_DAZED+RESIST):	  sprintf(outval, "%sresists, but still is more dazed.",cdesc);	break;      default:	sprintf(outval,"%sis affected in a mysterious way.",cdesc);    }    if (rad || (res != NO_RES)) { /* don't show normal hit msgs for bolts -CFT */	if (!blind)	    msg_print(outval);    }	}/* This fn provides the ability to have a spell blast a line of creatures   for damage.  It should look pretty neat, too... -CFT */voidline_spell(typ, dir, y, x, dam)int typ, dir, y, x, dam;{    int ny,nx, dis = 0, flag = FALSE;    int t, tdam;    monster_type *m_ptr;    cave_type *c_ptr;    int8u path[OBJ_BOLT_RANGE+5][3]; /* pre calculate "flight" path, makes bolt					calc faster because fns more likely to be in mem.					Also allows redraw at reasonable spd -CFT */      path[0][0] = y;  path[0][1] = x; /* orig point */    do {	(void)mmove(dir, &y, &x);	dis++;	path[dis][0] = y;  path[dis][1] = x;	if ((dis>OBJ_BOLT_RANGE) || (cave[y][x].fval >= MIN_CLOSED_SPACE))	    flag = TRUE;    } while (!flag);    flag = FALSE;    dis = 0;    do {	dis++;	y = path[dis][0];  x = path[dis][1];	c_ptr = &cave[y][x];	if ((dis > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)	    flag = TRUE;	/* then stop */	else {	    if (c_ptr->cptr > 1) { /* hit a monster! */		tdam = dam;		m_ptr = &m_list[c_ptr->cptr];		if (!(py.flags.status & PY_BLIND) && panel_contains(y,x)){		    /* temp light monster to show it... */		    t = c_ptr->pl;		    c_ptr->pl = TRUE;		    update_mon((int)c_ptr->cptr);		    c_ptr->pl = t;		    put_qio();	/* draw monster */		}		/* check resists */		spell_hit_monster(m_ptr, typ, &tdam, 1, &ny, &nx, TRUE);		c_ptr = &cave[ny][nx]; /* may be new loc if tele by grav warp */		(void) mon_take_hit((int)c_ptr->cptr, tdam, TRUE); /* hurt it */	    }	    if (!(py.flags.status & PY_BLIND)) {		for(t=1;t<=dis;t++)		    if (panel_contains(path[t][0],path[t][1])){#ifdef TC_COLOR			if (!no_color_flag) textcolor(bolt_color(typ));#endif			c_print(CC(spell_color(typ),bolt_char(path[t][0],path[t][1],path[t-1][0], path[t-1][1])),			      path[t][0], path[t][1]);#ifdef TC_COLOR			if (!no_color_flag) textcolor(LIGHTGRAY);#endif		    }		put_qio();	/* show line */#ifdef MSDOS		delay(8 * delay_spd);#else		usleep(8000 * delay_spd);#endif      	    } /* if !blind */	} /* if hit monster */    } while (!flag);		/* end of effects loop */      if (!(py.flags.status & PY_BLIND)) { /* now erase it -CFT */	for(t=1;t<=dis;t++){	/* erase piece-by-piece... */	    lite_spot(path[t][0], path[t][1]);	    for(tdam=t+1;tdam<dis;tdam++){		if (panel_contains(path[tdam][0], path[tdam][1])){#ifdef TC_COLOR		    if (!no_color_flag) textcolor(bolt_color(typ));#endif		    c_print(CC(spell_color(typ),bolt_char(path[tdam][0],path[tdam][1],path[tdam-1][0],				    path[tdam-1][1])), path[tdam][0], path[tdam][1]);#ifdef TC_COLOR		    if (!no_color_flag) textcolor(LIGHTGRAY);#endif		}	    }	    put_qio();#ifdef MSDOS	    delay(8 * delay_spd);#else	    usleep(8000 * delay_spd);#endif      	} /* for each piece */    } /* if !blind */}  /* Given a pointer to an worn item, return the letter   it is indexed by as shown with the 'e' command. Just   return a blank if we're given a bad pointer (i.e., something   which isn't being worn).   Note that returning		target - &inventory[INVEN_WIELD] + 'a'   doesn't work since the player may not have all of the   equipment slots filled.*/char inven_letter(target)inven_type *target;{	char c = 'a';	inven_type *iptr;	if (target < &inventory[INVEN_WIELD] ||            target > &inventory[INVEN_AUX] ||	    target->tval == TV_NOTHING)		return ' ';	for (iptr = &inventory[INVEN_WIELD]; iptr < target; ++iptr)		if (iptr->tval != TV_NOTHING)			++c; /* avoid c++ */	return c;}  