#include <MacHeaders>#include <string.h>#include <Palettes.h>#include "angband.h"#include "mac-io.h"#define CLEAR_CHAR ' 'int16u screen[SCRN_ROWS][SCRN_COLS];int cur_row,cur_col;int cursor_on;int getting_command=0;char recalltext[30][BIGVTYPESIZ];char choicestext[22][82];char choicescolor[22];char choicescolormin[22];char choicescolormax[22];char inventext[22][82];char invencolor[22];char invencolormin[22];char invencolormax[22];int choicesinven;RGBColor mac_clr[18]={	{65535,65535,65535},	/* 0 White */						{64512,62333,1327},		/* 1 Yellow */						{65535,25738,652},		/* 2 Orange */						{56683,2242,1698},		/* 3 Red */						{62167,2134,34028},		/* 4 Pink */						{18147,0,42302},		/* 5 Purple */						{0,0,54272},			/* 6 Blue */						{577,43860,60159},		/* 7 Light Blue */						{7969,46995,5169},		/* 8 Light Green */						{0,25775,4528},			/* 9 Green */						{22016,11421,1316},		/* 10 Brown */						{37079,29024,14900},	/* 11 Light Brown */						{49152,49152,49152},	/* 12 Light Gray */						{32768,32768,32768},	/* 13 Gray */						{16384,16384,16384},	/* 14 Dark Gray */						{0,0,0},				/* 15 Black */						{0,0,0},				/* 16 Multihued- not used */						{0,0,0},				/* 17 Floor color: set in InitScreen */					};int mac_pal_clr[18]={ 0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,0,0 };static int mh_index=3;  /* current color mh represents */static int mh_n=0;static int mh_row[100];		/* Keep track of any multihued screen characters here. */static int mh_col[100];		/* This MUST contain all current mh characters, but may contain ones no longer mh */static int16u *screenstack[4];static int16 depth=0;void setcolor(int n);void setcolor(int n){	if (rgbcolor==2)		RGBForeColor(&mac_clr[n]);	else if (rgbcolor==1)		PmForeColor(mac_pal_clr[n]);}void setfloorcolor(){	if (yellowfloor)		{			mac_clr[17]=mac_clr[1];			mac_pal_clr[17]=mac_pal_clr[1];		}	else /* light gray floor */		{			mac_clr[17]=mac_clr[12];			mac_pal_clr[17]=mac_pal_clr[12];		}}void InitScreen(){	int i,j;		for(i=0;i<SCRN_ROWS;i++)		for(j=0;j<SCRN_COLS;j++)			screen[i][j]=CC(MAC_WHITE,'+');	cur_row=cur_col=0;	cursor_on=FALSE;	mh_n=0;	mh_index=3;	setfloorcolor();		for(i=0;i<4;i++)		screenstack[i]=(int16u*)NewPtr(SCRN_ROWS*SCRN_COLS*sizeof(int16u));	depth=0;		for(i=0;i<30;i++)		for(j=0;j<BIGVTYPESIZ;j++)			recalltext[i][j]=' ';		for(i=0;i<22;i++)		{			for(j=0;j<80;j++)				inventext[i][j]=' ';			invencolor[i]=MAC_WHITE;		}	choicesinven=1;		InvalRect(&window->portRect);	InvalRect(&recallw->portRect);	InvalRect(&choicesw->portRect);}static void DrawCursor(){	Rect r;	r.left=cur_col*FONT_WIDTH;	r.right=r.left+FONT_WIDTH;	r.top=cur_row*FONT_HEIGHT;	r.bottom=r.top+FONT_HEIGHT;		setcolor(MAC_YELLOW);	FrameRect(&r);}void EraseCursor(){	Rect r;	r.left=cur_col*FONT_WIDTH;	r.right=r.left+FONT_WIDTH;	r.top=cur_row*FONT_HEIGHT;	r.bottom=r.top+FONT_HEIGHT;	EraseRect(&r);	MoveTo(cur_col*FONT_WIDTH+FONT_OFFSETH,FONT_HEIGHT*cur_row+FONT_OFFSETV);		if ((screen[cur_row][cur_col]>>8) == MAC_MULTIHUED)		setcolor(mh_index);	else		setcolor(screen[cur_row][cur_col]>>8);	DrawChar(screen[cur_row][cur_col] & 0xFF);}void DrawScreen(){	int i,j;	int color;	int start;	char text[SCRN_COLS];		EraseRect(&window->portRect);		FlushCQueue();		/* do each row separately */	for(i=0;i<SCRN_ROWS;i++)		{			/* for each row, break up into sections of one color */			start=0;			while(start!=SCRN_COLS)				{					color=screen[i][start]>>8;					for(j=start;j<SCRN_COLS;j++)						{							if (color!=(screen[i][j]>>8))   /* new color! after loop, j is index of first new color item */								break;							text[j-start]=screen[i][j]&0xFF;						}					if (color==MAC_MULTIHUED)						setcolor(mh_index);					else						setcolor(color);					MoveTo(FONT_WIDTH*start+FONT_OFFSETH,FONT_HEIGHT*i+FONT_OFFSETV);					DrawText(text,0,j-start);										start=j;				}		}	if (cursor_on)		DrawCursor();}void UpdateScreen(){}void DrawRecall(){	int i;	int start;	Rect r;	int cols,rows;		DrawControls(recallw);	r=recallw->portRect;	r.left=r.right-15;	ClipRect(&r);	DrawGrowIcon(recallw);	ClipRect(&recallw->portRect);		start=GetCtlValue(rscroll);		r=recallw->portRect;	r.right-=15;	EraseRect(&r);	cols=(r.right-4)/RECALL_FONT_WIDTH;	rows=r.bottom/RECALL_FONT_HEIGHT;	if (start+rows>30) rows=30-start;		for(i=start;i<start+rows;i++)		{			MoveTo(RECALL_FONT_OFFSETH+4,RECALL_FONT_HEIGHT*(i-start)+RECALL_FONT_OFFSETV);			DrawText(&recalltext[i][0],0,cols);		}}void DrawChoices(){	int i;	int start,end;	Rect r;	char *text;	char *color, *colormin, *colormax;		if (choicesinven==1)		{			text=&inventext[0][0];			color=invencolor;			colormin=invencolormin;			colormax=invencolormax;		}	else		{			text=&choicestext[0][0];			color=choicescolor;			colormin=choicescolormin;			colormax=choicescolormax;		}		DrawControls(choicesw);	r=choicesw->portRect;	r.left=r.right-15;	ClipRect(&r);	DrawGrowIcon(choicesw);	r=choicesw->portRect;	r.right-=15;	ClipRect(&r);	EraseRect(&r);		start=GetCtlValue(cscroll);	end=start+(r.bottom-r.top-1)/CHOICES_FONT_HEIGHT;	if (end>22) end=22;		for(i=start;i<end;i++)		{			if (color[i]==MAC_WHITE)				{					MoveTo(CHOICES_FONT_OFFSETH+4,CHOICES_FONT_HEIGHT*(i-start)+CHOICES_FONT_OFFSETV);					DrawText(&text[i*82],0,80);				}			else				{					MoveTo(CHOICES_FONT_OFFSETH+4,CHOICES_FONT_HEIGHT*(i-start)+CHOICES_FONT_OFFSETV);					DrawText(&text[i*82],0,colormin[i]);					setcolor(color[i]);					MoveTo(CHOICES_FONT_OFFSETH+4+CHOICES_FONT_WIDTH*colormin[i],CHOICES_FONT_HEIGHT*(i-start)+CHOICES_FONT_OFFSETV);					DrawText(&text[i*82],colormin[i],colormax[i]-colormin[i]);					setcolor(MAC_WHITE);					MoveTo(CHOICES_FONT_OFFSETH+4+CHOICES_FONT_WIDTH*colormax[i],CHOICES_FONT_HEIGHT*(i-start)+CHOICES_FONT_OFFSETV);					DrawText(&text[i*82],colormax[i],80-colormax[i]);				}		}	ClipRect(&choicesw->portRect);}void zerochoices(void);void zerochoices(){	register int i,j;	for(i=0;i<22;i++)		{			for(j=0;j<80;j++)				choicestext[i][j]=' ';			choicescolor[i]=MAC_WHITE;		}}void changeinven(){    register int i, j, k;    int          total_weight, l, lmax, lim;    bigvtype     tmp_val;    Rect		 r;		for(i=0;i<22;i++)		{			for(j=0;j<80;j++)				inventext[i][j]=' ';			invencolor[i]=MAC_WHITE;		}	    if (show_weight_flag)	lim = 68;    else	lim = 76;    k = 0;    lmax = 0;    for (i = 0; i < inven_ctr; i++) {	    objdes(tmp_val, &inventory[i], TRUE);	    tmp_val[lim] = 0;	   /* Truncate if too long. */		(void)sprintf(&inventext[k][0],"%c) %s",'a'+i,tmp_val);      	invencolor[k]=find_inven_color(&inventory[i]);      	invencolormin[k]=3;      	invencolormax[k]=3+strlen(tmp_val);		l = strlen(&inventext[k][0]);		if (l>lmax) lmax=l;		k++;	}	    if (show_weight_flag) {    	lmax+=2;    	j = 0;	    for (i = 0; i < inven_ctr; i++) {			total_weight = inventory[i].weight * inventory[i].number;			(void)sprintf(&inventext[j][lmax], "%3d.%d lb",				      (total_weight) / 10, (total_weight) % 10);		    j++;	    }	}		if (choicesinven)		{		    SetPort(choicesw);		    r=choicesw->portRect;		    r.right-=15;			InvalRect(&r);		    SetPort(window);		}}void clearchoices(){	Rect r;		if (choicesinven==1)		return;	    SetPort(choicesw);    r=choicesw->portRect;	if (choicesinven==2)		r.right=r.left+CHOICES_FONT_OFFSETH+4+2*CHOICES_FONT_WIDTH;	else  		r.right-=15;	InvalRect(&r);    SetPort(window);    	choicesinven=1;}void setchoicesinven(int r1, int r2, int weight, int (*test) (int)){    register int i, j, k;    int          total_weight, l, lmax, lim;    bigvtype     tmp_val;    Rect		 r;		if (r1==0 && r2==inven_ctr-1 && !test && choicesinven==1)		return;		for(i=0;i<22;i++)		{			choicestext[i][0]=' ';			choicestext[i][1]=' ';			for(j=2;j<80;j++)				choicestext[i][j]=inventext[i][j];			choicescolor[i]=invencolor[i];			choicescolormin[i]=invencolormin[i];			choicescolormax[i]=invencolormax[i];		}#if 0    if (weight)	lim = 68;    else	lim = 76;    lmax = 0;    for (i = r1; i <= r2; i++) {	if (test) {	    if ((*test) (object_list[inventory[i].index].tval)) {		objdes(tmp_val, &inventory[i], TRUE);		tmp_val[lim] = 0;  /* Truncate if too long. */		(void)sprintf(&choicestext[i][0],"%c) %s",'a'+i,tmp_val);      	choicescolor[i]=find_inven_color(&inventory[i]);      	choicescolormin[i]=3;      	choicescolormax[i]=3+strlen(tmp_val);		l = strlen(&choicestext[i][0]);		if (l>lmax) lmax=l;	    }	} else {	    objdes(tmp_val, &inventory[i], TRUE);	    tmp_val[lim] = 0;	   /* Truncate if too long. */		(void)sprintf(&choicestext[i][0],"%c) %s",'a'+i,tmp_val);      	choicescolor[i]=find_inven_color(&inventory[i]);      	choicescolormin[i]=3;      	choicescolormax[i]=3+strlen(tmp_val);		l = strlen(&choicestext[i][0]);		if (l>lmax) lmax=l;	}    }            if (weight) {    	lmax+=2;	    for (i = r1; i <= r2; i++) {			total_weight = inventory[i].weight * inventory[i].number;			(void)sprintf(&choicestext[i][lmax], "%3d.%d lb",				      (total_weight) / 10, (total_weight) % 10);	    }	}#endif		for(i = r1; i <= r2; i++)		if (!test || (*test)(object_list[inventory[i].index].tval))			{				choicestext[i][0]='a'+i;				choicestext[i][1]=')';			}	    SetPort(choicesw);    r=choicesw->portRect;    if (choicesinven)    	r.right=r.left+CHOICES_FONT_OFFSETH+4+2*CHOICES_FONT_WIDTH;    else    	r.right-=15;	InvalRect(&r);    SetPort(window);    	choicesinven=2;}void setchoicesequip(int weight){    register int i, j, line;    int                  total_weight, l, len, lim;    register const char *prt1;    bigvtype             prt2;    register inven_type *i_ptr;    Rect		 r;		zerochoices();	choicesinven=0;	    if (weight)	lim = 52;    else	lim = 60;		line=0;	len=0;    for (i = INVEN_WIELD; i < INVEN_ARRAY_SIZE; i++) {	i_ptr = &inventory[i];	if (i_ptr->tval != TV_NOTHING) {	    switch (i) {	      case INVEN_WIELD:		if (py.stats.use_stat[A_STR] * 15 < i_ptr->weight)		    prt1 = "Just lifting";		else		    prt1 = "Wielding";		break;	      case INVEN_HEAD:		prt1 = "On head";		break;	      case INVEN_NECK:		prt1 = "Around neck";		break;	      case INVEN_BODY:		prt1 = "On body";		break;	      case INVEN_ARM:		prt1 = "On arm";		break;	      case INVEN_HANDS:		prt1 = "On hands";		break;	      case INVEN_RIGHT:		prt1 = "On right hand";		break;	      case INVEN_LEFT:		prt1 = "On left hand";		break;	      case INVEN_FEET:		prt1 = "On feet";		break;	      case INVEN_OUTER:		prt1 = "About body";		break;	      case INVEN_LIGHT:		prt1 = "Light source";		break;	      case INVEN_AUX:		prt1 = "Spare weapon";		break;	      default:		prt1 = "Unknown value";		break;	    }	    objdes(prt2, &inventory[i], TRUE);	    prt2[lim] = 0;	   /* Truncate if necessary */	    (void)sprintf(&choicestext[line][0],"%c) %-14s: %s", (char)(line + 'a'), prt1, prt2);      	choicescolor[line]=find_inven_color(&inventory[i]);      	choicescolormin[line]=3+14+2;      	choicescolormax[line]=3+14+2+strlen(prt2);      	l=strlen(&choicestext[line][0]);      	if (l > len)      		len = l;      		    line++;	}    }		if (weight) {		len+=1;	    line = 0;	    for (i = INVEN_WIELD; i < INVEN_ARRAY_SIZE; i++) {		i_ptr = &inventory[i];			if (i_ptr->tval != TV_NOTHING) {				total_weight = i_ptr->weight * i_ptr->number;				sprintf(&choicestext[line][len], "%3d.%d lb", (total_weight) / 10, (total_weight) % 10);				line++;		    }		}	}	    SetPort(choicesw);    r=choicesw->portRect;    r.right-=15;	InvalRect(&r);    SetPort(window);}void setchoicesactivate(){	register int i,j;	bigvtype tmp2;    Rect		 r;		zerochoices();	choicesinven=0;		j=0;	for (i = 22; i < (INVEN_ARRAY_SIZE - 1); i++) {	    if ((inventory[i].flags2 & TR_ACTIVATE) &&		known2_p(&(inventory[i]))) {		objdes(tmp2, &inventory[i], TRUE);		sprintf(&choicestext[j][0], "%c) %-40s", 'a' + j, tmp2);      	choicescolor[j]=find_inven_color(&inventory[i]);      	choicescolormin[j]=3;      	choicescolormax[j]=80;/* No need to check for bottom of screen, since only have 11 items in equip, * so will never reach bottom... -CFT */		j++;	    }	}	SetPort(choicesw);	DrawChoices();	ValidRect(&choicesw->portRect);	SetPort(window);}void setchoicesspell(int *spell, int num, int nonconsec){    register int         i, j;    register spell_type *s_ptr;    int                  offset;    char                 spell_char;    Rect		 r;	zerochoices();	choicesinven=0;	    offset = (class[py.misc.pclass].spell == MAGE ? SPELL_OFFSET : PRAYER_OFFSET);    sprintf(&choicestext[0][3],"Name");    sprintf(&choicestext[0][34],"Lv Mana Fail");/* only show the first 22 choices */    if (num > 22)	num = 22;    for (i = 0; i < num; i++) {	j = spell[i];	s_ptr = &magic_spell[py.misc.pclass - 1][j];    /* determine whether or not to leave holes in character choices,     * nonconsec -1 when learning spells, consec offset>=0 when asking which     * spell to cast      */	if (nonconsec == -1)	    spell_char = 'a' + i;	else	    spell_char = 'a' + j - nonconsec;	(void)sprintf(&choicestext[i+1][0], "%c) %-30s%2d %4d %3d%%", spell_char,		      spell_names[j + offset], s_ptr->slevel, s_ptr->smana,		      spell_chance(j));    }    SetPort(choicesw);    r=choicesw->portRect;    r.right-=15;	InvalRect(&r);    SetPort(window);}void alert_error(char *c){	printf("%s\n",c);	SysBeep(1);}void clrtoeol(){	int i;	Rect r;		FlushCQueue();		for(i=cur_col;i<SCRN_COLS;i++)		screen[cur_row][i]=CC(MAC_WHITE,CLEAR_CHAR);	r.left=cur_col*FONT_WIDTH;	r.right=WIDTH;	r.top=cur_row*FONT_HEIGHT;	r.bottom=r.top+FONT_HEIGHT;	EraseRect(&r);}void move(int row,int col){	cur_row=row;	cur_col=col;}static void add_mhloc(int row,int col){	int i;		for(i=0;i<mh_n;i++)		if ((row==mh_row[i]) && (col==mh_col[i]))			break;	if (i==mh_n)   /* not already in list */		{			if (i==100)				return;  /* if over 100 multihued items, ignore those > 100 */			mh_row[i]=row;			mh_col[i]=col;			mh_n++;		}}int cycle_mh(){	int i;		FlushCQueue();		if (mh_n==0) return;		mh_index=randint(11);  /* get next multihued color: no white, grays, or black */		i=0;	while(i<mh_n)		{			if ((screen[mh_row[i]][mh_col[i]]>>8) != MAC_MULTIHUED)				{					/* no longer multihued- delete from list */					mh_n--;					mh_row[i]=mh_row[mh_n];					mh_col[i]=mh_col[mh_n];				}			else				{					setcolor(mh_index);					MoveTo(mh_col[i]*FONT_WIDTH+FONT_OFFSETH,FONT_HEIGHT*mh_row[i]+FONT_OFFSETV);					DrawChar(screen[mh_row[i]][mh_col[i]]&0xFF);					i++;				}		}}void mac_save_screen(){	int i;	int16u *from,*to;		FlushCQueue();		to=screenstack[depth];		from=(int16u*)screen;		for(i=0;i<SCRN_ROWS*SCRN_COLS;i++)		to[i]=from[i];		depth=depth+1;	if (depth==4) depth=0;}void mac_restore_screen(){	int i,j,k;	int16u *from,*to;	int change;	int min,max;	Rect r;	char text[80];	int start,color;		FlushCQueue();		depth=depth-1;	if (depth==-1) depth=3;	from=screenstack[depth];	to=(int16u*)screen;		/* cycle through rows- only redraw parts of those which need it */	for(i=0;i<SCRN_ROWS;i++)		{			change=0;			min=80;			max=-1;			for(j=0;j<SCRN_COLS;j++)				if (to[j]!=from[j])					{						change=1;						to[j]=from[j];						if (j<min) min=j;						if (j>max) max=j;					}			if (change)				{					r.left=min*FONT_WIDTH;					r.right=(max+1)*FONT_WIDTH;					r.top=i*FONT_HEIGHT;					r.bottom=r.top+FONT_HEIGHT;					EraseRect(&r);															/* for [min,max] array, break up into sections of one color */					start=min;					while(start!=max+1)						{							color=to[start]>>8;							for(j=start;j<=max;j++)								{									if (color!=(to[j]>>8))   /* new color! after loop, j is index of first new color item */										break;									text[j-start]=to[j]&0xFF;								}														if (color==MAC_MULTIHUED)								{									setcolor(mh_index);									for(k=start;k<j;k++)										add_mhloc(i,start+k);								}							else								setcolor(color);							MoveTo(FONT_WIDTH*start+FONT_OFFSETH,FONT_HEIGHT*i+FONT_OFFSETV);							DrawText(text,0,j-start);														start=j;						}				}						from+=SCRN_COLS;			to+=SCRN_COLS;		}}void mac_beep(){	SysBeep(1);}/* tail is full, head is empty */char charqueue[100];int head,tail=0;void machitkey(char c){	/* enter key */	if (c==3) c=13;	/* arrow keys */	if (c==28) c='4';	if (c==29) c='6';	if (c==30) c='8';	if (c==31) c='2';	charqueue[head]=c;	head=(head+1)%100;	if (head==tail)         /* overflow */		mac_bug("overflow in keyboard buffer (>99 keystrokes)");}void macgetkey(char *c){	FlushCQueue();	while (head==tail)		{			if (cursor_on==FALSE && !getting_command)				{					cursor_on=TRUE;					DrawCursor();				}			events();		}	*c=charqueue[tail];	tail=(tail+1)%100;		if (cursor_on==TRUE)		{			cursor_on=FALSE;			EraseCursor();		}}void FlushScreenKeys(){	FlushCQueue();		while(events());   /* flush event queue */	head=tail=0;}/* return 1 if there is a keyboard hit */int check_input(int junk){	EventRecord event;		FlushCQueue();		if (head!=tail) return(1);		events(); /* handle events & let other processes get work done */		return(0);}typedef struct CQueueElem{	int8u y;	int8u x;	int16u c;} CQueueElem;int CQueueLen=0;CQueueElem CQueue[1000];void CWriteScreenChar(int16u c){	int i;		/* if loc already in queue, replace char */	for(i=0;i<CQueueLen;i++)		{			if ((CQueue[i].y == cur_row) && (CQueue[i].x == cur_col))				{					CQueue[i].c = c;					cur_col++;					if (cur_col>SCRN_COLS) cur_col=SCRN_COLS;					return;				}		}		if (screen[cur_row][cur_col]==c)		{			/* already there!  Used to speed up wide-area light and such */			cur_col++;			if (cur_col>SCRN_COLS) cur_col=SCRN_COLS;			return;		}		/* if queue too long, flush it */	if (CQueueLen == 1000)		FlushCQueue();		/* add to end of queue */	CQueue[CQueueLen].y = cur_row;	CQueue[CQueueLen].x = cur_col;	CQueue[CQueueLen].c = c;	CQueueLen++;	cur_col++;	if (cur_col>SCRN_COLS) cur_col=SCRN_COLS;}void FlushCQueue(){	int i;	int saverow,savecol;		if (CQueueLen==0) return;		saverow=cur_row;	savecol=cur_col;	for(i=0;i<CQueueLen;i++)		{			cur_row = CQueue[i].y;			cur_col = CQueue[i].x;			CWriteScreenChar_old(CQueue[i].c);		}	CQueueLen=0;		cur_row=saverow;	cur_col=savecol;}void CWriteScreenChar_old(int16u c){	Rect r;	char str[100];		if (screen[cur_row][cur_col]==c)		{			/* already there!  Used to speed up wide-area light and such */			cur_col++;			if (cur_col>SCRN_COLS) cur_col=SCRN_COLS;			return;		}		r.left=cur_col*FONT_WIDTH;	r.right=r.left+FONT_WIDTH;	r.top=FONT_HEIGHT*cur_row;	r.bottom=r.top+FONT_HEIGHT;	EraseRect(&r);	if ((c>>8)==MAC_MULTIHUED)		{			setcolor(mh_index);			add_mhloc(cur_row,cur_col);		}	else		setcolor(c>>8);	if (c>>8==MAC_BLACK)		{			sprintf(str,"printing character '%c' in black",(char)(c&0xFF));			mac_warning(str);		}	MoveTo(cur_col*FONT_WIDTH+FONT_OFFSETH,FONT_HEIGHT*cur_row+FONT_OFFSETV);	DrawChar(c&0xFF);		screen[cur_row][cur_col]=c;	/* cur_col++; */}void CWriteScreenString(int16u *c){	int i,j,k,len,start,color;	Rect r;	char text[80];	char str[100];		FlushCQueue();		for(i=0;c[i]!=0;i++);	len=i;		/* prune overwrites */	if (cur_col+len > SCRN_COLS)		len=SCRN_COLS-cur_col;		r.left=cur_col*FONT_WIDTH;	r.right=r.left+len*FONT_WIDTH;	r.top=FONT_HEIGHT*cur_row;	r.bottom=r.top+FONT_HEIGHT;	EraseRect(&r);		/* break up into sections of one color */	start=0;	while(start!=len)		{			color=c[start]>>8;			for(j=start;j<len;j++)				{					if (color!=(c[j]>>8))   /* new color! after loop, j is index of first new color item */						break;					text[j-start]=c[j]&0xFF;				}						if (color==MAC_MULTIHUED)				{					setcolor(mh_index);					for(k=start;k<j;k++)						add_mhloc(cur_row,cur_col+k);				}			else				setcolor(color);			if (color==MAC_BLACK)				{					sprintf(str,"printing character '%c' in black",(char)text[0]);					mac_warning(str);				}			MoveTo(FONT_WIDTH*(cur_col+start)+FONT_OFFSETH,FONT_HEIGHT*cur_row+FONT_OFFSETV);			DrawText(text,0,j-start);						start=j;		}		for(i=0;i<len;i++)		screen[cur_row][cur_col+i]=c[i];	cur_col+=len;}void DWriteScreenCharAttr(char c,int attr){	Rect r;	FlushCQueue();		r.left=cur_col*FONT_WIDTH;	r.right=r.left+FONT_WIDTH;	r.top=FONT_HEIGHT*cur_row;	r.bottom=r.top+FONT_HEIGHT;	EraseRect(&r);	setcolor(MAC_WHITE);	MoveTo(cur_col*FONT_WIDTH+FONT_OFFSETH,FONT_HEIGHT*cur_row+FONT_OFFSETV);	DrawChar(c);		screen[cur_row][cur_col]=CC(MAC_WHITE,c);	cur_col++;	if (cur_col>SCRN_COLS) cur_col=SCRN_COLS;}void DWriteScreenStringAttr(char *c,int attr){	int i,len;	Rect r;		FlushCQueue();		len=strlen(c);		/* prune overwrites */	if (cur_col+len > SCRN_COLS)		len=SCRN_COLS-cur_col;		r.left=cur_col*FONT_WIDTH;	r.right=r.left+len*FONT_WIDTH;	r.top=FONT_HEIGHT*cur_row;	r.bottom=r.top+FONT_HEIGHT;	EraseRect(&r);	setcolor(MAC_WHITE);	MoveTo(cur_col*FONT_WIDTH+FONT_OFFSETH,FONT_HEIGHT*cur_row+FONT_OFFSETV);	DrawText(c,0,len);		for(i=0;i<len;i++)		screen[cur_row][cur_col+i]=CC(MAC_WHITE,c[i]);	cur_col+=len;	}void DWriteScreenString(char *c){	DWriteScreenStringAttr(c,attrNormal);}void DSetScreenCursor(int col, int row){	cur_col=col;	cur_row=row;}void GetScreenCursor(int *x,int *y){	*x=cur_col;	*y=cur_row;}void EraseScreen(Rect *r){	int i,j;	Rect r2;		FlushCQueue();		for(i=r->top;i<r->bottom;i++)		for(j=r->left;j<r->right;j++)			screen[i][j]=CC(MAC_WHITE,CLEAR_CHAR);		r2.left=r->left*FONT_WIDTH;	r2.right=r->right*FONT_WIDTH;	r2.top=r->top*FONT_HEIGHT;	r2.bottom=r->bottom*FONT_HEIGHT;		EraseRect(&r2);}void DEraseScreen(Rect *r){	EraseScreen(r);}void refresh(){	FlushCQueue();}void clear_recall(){	int i,j;	Rect r;		SetPort(recallw);		for(i=0;i<30;i++)		for(j=0;j<BIGVTYPESIZ;j++)			recalltext[i][j]=' ';		SetCtlValue(rscroll,0);		r=recallw->portRect;	r.right-=15;	EraseRect(&r);		SetPort(window);}void recall_prt(char *text,int row,int col){	Rect r;	int i,len;	int start;		if (row>=30)		return;		SetPort(recallw);		start=GetCtlValue(rscroll);		len=strlen(text);		MoveTo(col*RECALL_FONT_WIDTH+RECALL_FONT_OFFSETH+4,RECALL_FONT_HEIGHT*(row-start)+RECALL_FONT_OFFSETV);	DrawText(text,0,len);		for(i=0;i<len;i++)		recalltext[row][col+i]=text[i];	for(i=len;i<BIGVTYPESIZ;i++)		recalltext[row][i]=' ';		SetPort(window);}int extractdir(char c,int *shift_flag,int *ctrl_flag){	int dir=-1;		if (c=='1') dir=1;	if (c=='2') dir=2;	if (c=='3') dir=3;	if (c=='4') dir=4;	if (c=='5') dir=5;	if (c=='6') dir=6;	if (c=='7') dir=7;	if (c=='8') dir=8;	if (c=='9') dir=9;	return(dir);}void addch(char c){	DWriteScreenCharAttr(c,attrNormal);}int mac_file_character(){	SFReply reply;	Str255 default_name;	char *f;	Point topleft;	short vrefnum;	long drefnum,longjunk;		if (py.misc.name[strlen(py.misc.name)-1]=='s' || py.misc.name[strlen(py.misc.name)-1]=='S')		sprintf((char*)default_name+1,"%s' description",py.misc.name);	else		sprintf((char*)default_name+1,"%s's description",py.misc.name);	default_name[0]=strlen((char*)default_name+1);		topleft.h=(qd.screenBits.bounds.left+qd.screenBits.bounds.right)/2-344/2;	topleft.v=(2*qd.screenBits.bounds.top+qd.screenBits.bounds.bottom)/3-188/2;	SFPutFile(topleft,"\pSave description as:",default_name,NULL,&reply);	/* StandardPutFile("\pSave description as:",default_name,&reply); */	if (reply.good)		{			GetWDInfo(reply.vRefNum,&vrefnum,&drefnum,&longjunk);			f=refnum_to_name(drefnum,vrefnum,(char*)reply.fName);			return(file_character(f));		}	return(FALSE);}int gotlibdir;short libvol;long libdir;pascal Boolean foldersonlyfilter(ParmBlkPtr pb, void *junk);pascal Boolean foldersonlyfilter(ParmBlkPtr pb, void *junk){	FileParam *d=(FileParam*)pb;	return( !(d->ioFlAttrib & (1<<4)));}pascal short findlibdialoghook(short item, DialogPtr dialog, void *junk);pascal short findlibdialoghook(short item, DialogPtr dialog, void *junk){	if (item==2) gotlibdir=0;	if (item!=10)		return(item);		return(sfItemCancelButton);}int find_and_set_lib_dir(){	Point topleft;	StandardFileReply reply;	SFTypeList t;	short vrefnum;	long drefnum,longjunk;	char *name;	long response;	AlertTHndl alert;	FILE *f;		/* I need StandardGetFile to make this work... */	Gestalt(gestaltStandardFileAttr,&response);	if (!(response & (1<<gestaltStandardFile58)))		{			alert=(AlertTHndl)GetResource('ALRT',130);			center_rect(&(*alert)->boundsRect,&qd.screenBits.bounds);			Alert(130,NULL);			MacExit();		}		/* try hints in prefs file */	if (!HSetVol(0, volhint, dirhint))		{		    if ((f = fopen(ANGBAND_MOR, "r")) != NULL)		    	{		    		/* hint was successful! */		    		fclose(f);		    		return(1);		    	}		}		tryagain:		SysBeep(1);	topleft.h=topleft.v=-1;	gotlibdir=1;		CustomGetFile(foldersonlyfilter,-1,t,&reply,130,topleft,findlibdialoghook,NULL,				  NULL,NULL,NULL);	if (gotlibdir)		{			HSetVol(0,reply.sfFile.vRefNum,reply.sfFile.parID);			if ((f = fopen(ANGBAND_MOR, "r")) != NULL)		    	{		    		/* hint was successful! */		    		fclose(f);		    		/* save vol/dir for next time */		    		volhint = reply.sfFile.vRefNum;		    		dirhint = reply.sfFile.parID;		    		return(1);		    	}			goto tryagain;		}	else		MacExit();	#if 0	topleft.h=(qd.screenBits.bounds.left+qd.screenBits.bounds.right)/2-344/2;	topleft.v=(2*qd.screenBits.bounds.top+qd.screenBits.bounds.bottom)/3-197/2;		gotlibdir=1;	SFPGetFile(topleft,"\pLocate lib directory",foldersonlyfilter,1,t,findlibdialoghook,				&reply, 131, NULL);		if (gotlibdir)		{			GetWDInfo(reply.vRefNum,&vrefnum,&drefnum,&longjunk);						name=refnum_to_name(drefnum,vrefnum,(char*)reply.fName);			printf("%s\n",name);						HSetVol(0,vrefnum,drefnum);			CloseWD(reply.vRefNum);			return(1); /* found & reset volume/directory */		}	else		return(0);  /* user cancelled */#endif}