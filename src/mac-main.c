#include <MacHeaders>#include <GestaltEqu.h>#include <Palettes.h>#include <string.h>#include "angband.h"#include "mac-io.h"#include <unix.h>int FONT_WIDTH;int FONT_HEIGHT;int FONT_OFFSETH;int FONT_OFFSETV;int WIDTH;int HEIGHT;int RECALL_FONT_WIDTH;int RECALL_FONT_HEIGHT;int RECALL_FONT_OFFSETH;int RECALL_FONT_OFFSETV;int CHOICES_FONT_WIDTH;int CHOICES_FONT_HEIGHT;int CHOICES_FONT_OFFSETH;int CHOICES_FONT_OFFSETV;WindowPtr window;WindowPtr recallw;WindowPtr choicesw;ControlHandle rscroll,cscroll;short recall_hidden=0;short choices_hidden=0;short volhint;long dirhint;short yellowfloor=1;short angbandbold=0;short recallbold=0;short choicesbold=0;int game_in_progress=0;int save_enabled;short getshort(FILE *f);short getshort(FILE *f){	short x;	if (fscanf(f,"%d",&x)!=1)		return(0);	return(x);}void putshort(FILE *f, short x);void putshort(FILE *f, short x){	fprintf(f,"%d\n",x);}long getlong(FILE *f);long getlong(FILE *f){	long x;	if(fscanf(f,"%ld",&x)!=1)		return(0);	return(x);}void putlong(FILE *f, long x);void putlong(FILE *f, long x){	fprintf(f,"%ld\n",x);}void center_rect(Rect *r, Rect *s){	int centerx = (s->left + s->right)/2;	int centery = (2*s->top + s->bottom)/3;	int dx = centerx - (r->right - r->left)/2 - r->left;	int dy = centery - (r->bottom - r->top)/2 - r->top;	r->left += dx;	r->right += dx;	r->top += dy;	r->bottom += dy;}short recallfont,recallsize,angbandfont,angbandsize,choicesfont,choicessize;static void getsize_angband(){	Rect r;	WindowPtr tmpw;	FontInfo info;		r.left=r.right=r.top=r.bottom=0;	tmpw=NewWindow(0,&r,"\p",false,documentProc,0,0,0);	SetPort(tmpw);		TextFont(angbandfont);	TextSize(angbandsize);	TextFace(angbandbold);	GetFontInfo(&info);	FONT_WIDTH=CharWidth('@'); /* info.widMax; */	FONT_HEIGHT=info.ascent+info.descent;	FONT_OFFSETH=0;	FONT_OFFSETV=info.ascent;		WIDTH=SCRN_COLS*FONT_WIDTH;	HEIGHT=SCRN_ROWS*FONT_HEIGHT;		DisposeWindow(tmpw);	SetPort(window);		/* printf("width: %d, height: %d\n",FONT_WIDTH,FONT_HEIGHT); */}static void getsize_recall(){	Rect r;	WindowPtr tmpw;	FontInfo info;		r.left=r.right=r.top=r.bottom=0;	tmpw=NewWindow(0,&r,"\p",false,documentProc,0,0,0);	SetPort(tmpw);		TextFont(recallfont);	TextSize(recallsize);	TextFace(recallbold);	GetFontInfo(&info);	RECALL_FONT_WIDTH=CharWidth('@'); /* info.widMax; */	RECALL_FONT_HEIGHT=info.ascent+info.descent;	RECALL_FONT_OFFSETH=0;	RECALL_FONT_OFFSETV=info.ascent;		DisposeWindow(tmpw);	SetPort(window);}static void getsize_choices(){	Rect r;	WindowPtr tmpw;	FontInfo info;		r.left=r.right=r.top=r.bottom=0;	tmpw=NewWindow(0,&r,"\p",false,documentProc,0,0,0);	SetPort(tmpw);		TextFont(choicesfont);	TextSize(choicessize);	TextFace(choicesbold);	GetFontInfo(&info);	CHOICES_FONT_WIDTH=CharWidth('@'); /* info.widMax; */	CHOICES_FONT_HEIGHT=info.ascent+info.descent;	CHOICES_FONT_OFFSETH=0;	CHOICES_FONT_OFFSETV=info.ascent;		DisposeWindow(tmpw);	SetPort(window);}static void init_window(){	Rect recallr,angbandr,choicesr,r;	RGBColor c;	SysEnvRec env;	FILE *f;	short savev;	long saved;	PaletteHandle p;	int i;		SysEnvirons(curSysEnvVers, &env);	HGetVol(0,&savev,&saved);	SetVol(0, env.sysVRefNum);	f=fopen(":Preferences:Angband 2.6.2 Preferences","r");	if (!f)		f=fopen(":Angband 2.6.2 Preferences","r");	HSetVol(0,savev,saved);	if (f)		{			angbandfont=getshort(f);			angbandsize=getshort(f);						angbandr.left=getshort(f);			angbandr.top=getshort(f);						recallfont=getshort(f);			recallsize=getshort(f);						recallr.left=getshort(f);			recallr.top=getshort(f);			recallr.right=getshort(f);			recallr.bottom=getshort(f);						/* added hidden flag for recall window to preferences */			recall_hidden=getshort(f);						/* get volume and directory hints for lib directory */			volhint=getshort(f);			dirhint=getlong(f);						/* get more stuff */			yellowfloor=1-getshort(f);			angbandbold=getshort(f);			recallbold=getshort(f);						/* choices window stuff */			choicesfont=getshort(f);			choicessize=getshort(f);			choicesbold=getshort(f);						if (choicesfont==0 || choicessize==0)				{					GetFNum("\pmonaco",&choicesfont);					choicessize=9;					choicesbold=0;					choicesr.left=qd.screenBits.bounds.right - 210;					choicesr.right=choicesr.left+200;					choicesr.top=angbandr.top;					choicesr.bottom=-1;					choices_hidden=0;				}			else				{					choicesr.left=getshort(f);					choicesr.top=getshort(f);					choicesr.right=getshort(f);					choicesr.bottom=getshort(f);										choices_hidden=getshort(f);				}			/* get width and height of font */			getsize_angband();			angbandr.right=angbandr.left+WIDTH;			angbandr.bottom=angbandr.top+HEIGHT;						/* get width and height of font */			getsize_recall();						/* get width and height of font */			getsize_choices();			if (choicesr.bottom==-1)				choicesr.bottom=choicesr.top+22*CHOICES_FONT_HEIGHT;						fclose(f);		}	else		{			GetFNum("\pmonaco",&angbandfont);			choicesfont=recallfont=angbandfont;			choicessize=recallsize=angbandsize=9;			choicesbold=recallbold=angbandbold=0;			recall_hidden=0;			choices_hidden=0;			yellowfloor=1;						getsize_angband();						getsize_recall();						getsize_choices();						angbandr.left=20;			angbandr.top=60;			angbandr.right=angbandr.left+WIDTH;			angbandr.bottom=angbandr.top+HEIGHT;						recallr.left=20;			recallr.top=60+HEIGHT+40;			if (recallr.top > qd.screenBits.bounds.bottom - FONT_HEIGHT*RECALL_ROWS)				recallr.top = qd.screenBits.bounds.bottom - FONT_HEIGHT*RECALL_ROWS;			recallr.right=recallr.left+WIDTH;			recallr.bottom=recallr.top+FONT_HEIGHT*RECALL_ROWS;						choicesr.top=angbandr.top;			choicesr.left=angbandr.right+40;			if (choicesr.left > qd.screenBits.bounds.right-200)				choicesr.left = qd.screenBits.bounds.right-200;			choicesr.right=choicesr.left+200;			choicesr.bottom=choicesr.top+22*CHOICES_FONT_HEIGHT;		}		if (rgbcolor)		choicesw=NewCWindow(0,&choicesr,"\pChoices",1-choices_hidden,documentProc,(WindowPtr)-1,1,0);	else		choicesw=NewWindow(0,&choicesr,"\pChoices",1-choices_hidden,documentProc,(WindowPtr)-1,1,0);	SetPort(choicesw);		TextFont(choicesfont);	TextSize(choicessize);	TextFace(choicesbold);		r = choicesw->portRect;	r.left = r.right-15;	r.right += 1;	r.bottom -= 14;	r.top -= 1;	cscroll = NewControl( choicesw, &r, "\p", 1, 0, 0, 21, scrollBarProc, 0L);	SetControlMaximum(cscroll, 22-(choicesw->portRect.bottom - choicesw->portRect.top-1)/CHOICES_FONT_HEIGHT);	HiliteControl(cscroll,255);		if (rgbcolor==2)		{			c.red=0;			c.green=0;			c.blue=0;			RGBBackColor(&c);			c.red=0xFFFF;			c.green=0xFFFF;			c.blue=0xFFFF;			RGBForeColor(&c);		}	else if (rgbcolor==1)		{			p=GetNewPalette(128);			NSetPalette(window,p,pmAllUpdates);			BackColor(blackColor);			ForeColor(whiteColor);		}	else		{			BackColor(blackColor);			ForeColor(whiteColor);		}	if (rgbcolor)		recallw=NewCWindow(0,&recallr,"\pRecall",1-recall_hidden,documentProc,(WindowPtr)-1,1,0);	else		recallw=NewWindow(0,&recallr,"\pRecall",1-recall_hidden,documentProc,(WindowPtr)-1,1,0);	SetPort(recallw);		TextFont(recallfont);	TextSize(recallsize);	TextFace(recallbold);		r = recallw->portRect;	r.left = r.right-15;	r.right += 1;	r.bottom -= 14;	r.top -= 1;	rscroll = NewControl( recallw, &r, "\p", 1, 0, 0, 29, scrollBarProc, 0L);	HiliteControl(rscroll,255);		if (rgbcolor)		window=NewCWindow(0,&angbandr,"\pAngband",true,noGrowDocProc,(WindowPtr)-1,0,0);	else		window=NewWindow(0,&angbandr,"\pAngband",true,noGrowDocProc,(WindowPtr)-1,0,0);	SetPort(window);		TextFont(angbandfont);	TextSize(angbandsize);	TextFace(angbandbold);		if (rgbcolor==2)		{			c.red=0;			c.green=0;			c.blue=0;			RGBBackColor(&c);			c.red=0xFFFF;			c.green=0xFFFF;			c.blue=0xFFFF;			RGBForeColor(&c);		}	else if (rgbcolor==1)		{			p=GetNewPalette(128);			NSetPalette(window,p,pmAllUpdates);			BackColor(blackColor);			ForeColor(whiteColor);		}	else		{			BackColor(blackColor);			ForeColor(whiteColor);		}}void MacExit(){	SysEnvRec env;	FILE *f;	Point p;		SysEnvirons(curSysEnvVers, &env);	SetVol(0, env.sysVRefNum);	_ftype='TEXT';	f=fopen(":Preferences:Angband 2.6.2 Preferences","w");	if (!f)		f=fopen(":Angband 2.6.2 Preferences","w");		putshort(f,angbandfont);	putshort(f,angbandsize);	SetPort(window);	p.h=window->portRect.left;	p.v=window->portRect.top;	LocalToGlobal(&p);	putshort(f,p.h);	putshort(f,p.v);		putshort(f,recallfont);	putshort(f,recallsize);	SetPort(recallw);	p.h=recallw->portRect.left;	p.v=recallw->portRect.top;	LocalToGlobal(&p);	putshort(f,p.h);	putshort(f,p.v);	p.h=recallw->portRect.right;	p.v=recallw->portRect.bottom;	LocalToGlobal(&p);	putshort(f,p.h);	putshort(f,p.v);		putshort(f,recall_hidden);		putshort(f,volhint);	putlong(f,dirhint);		putshort(f,1-yellowfloor);	putshort(f,angbandbold);	putshort(f,recallbold);		putshort(f,choicesfont);	putshort(f,choicessize);	putshort(f,choicesbold);		SetPort(choicesw);	p.h=choicesw->portRect.left;	p.v=choicesw->portRect.top;	LocalToGlobal(&p);	putshort(f,p.h);	putshort(f,p.v);	p.h=choicesw->portRect.right;	p.v=choicesw->portRect.bottom;	LocalToGlobal(&p);	putshort(f,p.h);	putshort(f,p.v);			putshort(f,choices_hidden);		fclose(f);	ExitToShell();}static void init_menu(){	MenuHandle menu;	SetMenuBar(GetNewMBar(128));	menu=GetMenu(128);	AddResMenu(menu,'DRVR');	InsertMenu(menu,129);	/*	menu=GetMenu(131);	AddResMenu(menu,'FONT');	InsertMenu(menu,132);	*/	DrawMenuBar();}static void disable_start()  /* disables new and open from file menu */{	MenuHandle m;	m=GetMHandle(129);	DisableItem(m,1);	DisableItem(m,2);}void enable_save(void);void enable_save()    /* enables save/save&quit from file menu */{	save_enabled=1;}void disable_save(void);static void disable_save()   /* disables save/save&quit from file menu */{	save_enabled=0;}void setup_menus(){	MenuHandle m;	int i;	short fnum,fsize,currfsize;	Str255 s;		/* File menu */	m=GetMHandle(129);	if (save_enabled)		{			EnableItem(m,3);			EnableItem(m,8);		}	else		{			DisableItem(m,3);			DisableItem(m,8);		}	if (recall_hidden)		SetItem(m,5,"\pShow Recall");	else		SetItem(m,5,"\pHide Recall");		if (choices_hidden)		SetItem(m,6,"\pShow Choices");	else		SetItem(m,6,"\pHide Choices");	/* Font menu */	m=GetMHandle(131);	if (FrontWindow()==window)		{			if(angbandbold)				CheckItem(m,1,1);			else				CheckItem(m,1,0);		}	if (FrontWindow()==recallw)		{			if(recallbold)				CheckItem(m,1,1);			else				CheckItem(m,1,0);		}	if (FrontWindow()==choicesw)		{			if(choicesbold)				CheckItem(m,1,1);			else				CheckItem(m,1,0);		}		for(i=3;i<=CountMItems(m);i++)		{			GetItem(m,i,s);			GetFNum(s,&fnum);			if ((fnum==angbandfont && FrontWindow()==window) ||					(fnum==recallfont && FrontWindow()==recallw) ||					(fnum==choicesfont && FrontWindow()==choicesw))				CheckItem(m,i,1);			else				CheckItem(m,i,0);		}		/* Size menu */	m=GetMHandle(132);	if (FrontWindow()==window)		{fnum=angbandfont;currfsize=angbandsize;}	if (FrontWindow()==recallw)		{fnum=recallfont;currfsize=recallsize;}	if (FrontWindow()==choicesw)		{fnum=choicesfont;currfsize=choicessize;}	for(i=1;i<=CountMItems(m);i++)		{			GetItem(m,i,s);			s[s[0]+1]=0;			fsize=atoi((char*)(s+1));			if (RealFont(fnum,fsize))				EnableItem(m,i);			else				DisableItem(m,i);			if (fsize==currfsize)				CheckItem(m,i,1);			else				CheckItem(m,i,0);		}		/* Other menu */	m=GetMHandle(133);		if (yellowfloor)		CheckItem(m,1,1);	else		CheckItem(m,1,0);}void mac_warning(char *warning){	Str255 text;	int len,i;		len=strlen(warning);	text[0]=len;	for(i=0;i<len;i++)		text[i+1]=warning[i];		ParamText(text,"\p","\p","\p");	Alert(129,0L);}void mac_bug(char *c){	char msg[1000];	int len,len2;	int i;	char app[]="   Attempting save and exiting.  Goodbye!";		len=strlen(c);	for(i=0;i<len;i++)		msg[i]=c[i];	len2=strlen(app);	for(i=0;i<len2;i++)		msg[i+len]=app[i];	mac_warning(msg);	save_char();	ExitToShell();}char *refnum_to_name(long refnum,short vrefnum,char *fname){	DirInfo pb;	Str255 name;	int err;	int i,j;		char *res;		res=NewPtr(1000);	i=999;	res[i]=0;i--;	for(j=1;j<=fname[0];j++)		res[i-fname[0]+j]=fname[j];	i-=fname[0];		pb.ioCompletion=NULL;	pb.ioNamePtr=name;	pb.ioVRefNum=vrefnum;	pb.ioDrParID=refnum;	pb.ioFDirIndex=-1;	do		{			pb.ioDrDirID=pb.ioDrParID;			err=PBGetCatInfo((CInfoPBPtr)&pb,FALSE);			res[i]=':';i--;			for(j=1;j<=name[0];j++)				res[i-name[0]+j]=name[j];			i-=name[0];		}			while(pb.ioDrDirID!=fsRtDirID);	return(&res[i+1]);}pascal Boolean ynfilter (DialogPtr dialog, EventRecord *event, short *item);pascal Boolean ynfilter (DialogPtr dialog, EventRecord *event, short *item){	char c;	long t;	ControlHandle control;	Rect r;	short type;		if (event->what == keyDown)		{			c=event->message&charCodeMask;			if (c=='y' || c=='Y')				{					GetDItem(dialog,2,&type,(Handle*)&control,&r);					HiliteControl(control,1);					t=TickCount();					while(TickCount()-t<6);					HiliteControl(control,0);					*item=2;					return(1);				}			if (c=='n' || c=='N' || c==13 || c==3 || c==27 || (c==46 && event->modifiers&cmdKey))				{					GetDItem(dialog,1,&type,(Handle*)&control,&r);					HiliteControl(control,1);					t=TickCount();					while(TickCount()-t<6);					HiliteControl(control,0);					*item=1;					return(1);				}		}	return(0);}static void menu(long choice){	int menuid,selection;	static unsigned char s[1000];	SFTypeList types;	SFReply reply;	int err;	DialogPtr dialog;	short item_hit;	Point topleft;	Point botright;	Rect r;	AlertTHndl alert;	int i;	int32 j;	char *tmp;		short vrefnum;	long drefnum;	long longjunk;	DirInfo pb;		menuid=HiWord(choice);	selection=LoWord(choice);	switch (menuid)		{			case 128:				if (selection==1)					{						dialog=GetNewDialog(128,0,(WindowPtr)-1);												r=dialog->portRect;						center_rect(&r,&qd.screenBits.bounds);						MoveWindow(dialog,r.left,r.top,1);						ShowWindow(dialog);						ModalDialog(0,&item_hit);						DisposDialog(dialog);						break;					}				GetItem(GetMHandle(128),selection,s);				OpenDeskAcc(s);				break;			case 129:				switch (selection)					{						case 1: /* new game */							if (game_in_progress)								{									mac_warning("You can't start a new game while you're still playing!");								}							else								{									HiliteMenu(0);									game_in_progress=1;									disable_start();									savefile=NewPtr(1000); /* allocate space for savefile name */									unix_main(TRUE);									/* never returns from this call... */								}							break;						case 2: /* open game */							if (game_in_progress)								{									mac_warning("You can't open a new game while you're still playing!");								}							else								{									types[0]='SAVE';									vrefnum=-*((short*)0x214); /* vrefnum=GetSFCurVol(); */									drefnum=*((long*)0x398);   /* drefnum=GetSFCurDir(); */																		/* descend into lib directory if possible */									pb.ioCompletion=NULL;									pb.ioNamePtr="\plib";									pb.ioVRefNum=vrefnum;									pb.ioDrDirID=drefnum;									pb.ioFDirIndex=0;																		err=PBGetCatInfo((CInfoPBPtr)&pb,FALSE);									if (err!=noErr) goto do_sf;									if (!(pb.ioFlAttrib & 0x10))										goto do_sf;																		/* descend into save directory if possible */									pb.ioCompletion=NULL;									pb.ioNamePtr="\psave";									pb.ioVRefNum=vrefnum;									pb.ioDrDirID=pb.ioDrDirID;									pb.ioFDirIndex=0;									err=PBGetCatInfo((CInfoPBPtr)&pb,FALSE);									if (err!=noErr) goto do_sf;									if (!(pb.ioFlAttrib & 0x10))										goto do_sf;																			*((long*)0x398)=pb.ioDrDirID; /* SetSFCurDir(pb.ioDrDirID); */									do_sf:									topleft.h=(qd.screenBits.bounds.left+qd.screenBits.bounds.right)/2-344/2;									topleft.v=(2*qd.screenBits.bounds.top+qd.screenBits.bounds.bottom)/3-188/2;									SFGetFile(topleft,"\p",NULL,1,types,NULL,&reply);									if (reply.good)										{											GetWDInfo(reply.vRefNum,&vrefnum,&drefnum,&longjunk);											savefile=refnum_to_name(drefnum,vrefnum,(char*)reply.fName);											game_in_progress=1;											disable_start();											HiliteMenu(0);											unix_main(FALSE);											/* it will never return to here! */										}									/*  This code is System 7 specific!									StandardGetFile(NULL,1,types,&reply);									if (reply.sfGood)										{											savefile=refnum_to_name(reply.sfFile.parID,reply.sfFile.vRefNum,(char*)reply.sfFile.name);											game_in_progress=1;											disable_start();											HiliteMenu(0);											unix_main(FALSE);											/ it will never return to here! /										}									*/								}							break;						case 3: /* save game */							if (game_in_progress)								{									cursor_on=0;									EraseCursor();																		if (total_winner) {									    msg_print("You are a Total Winner,  your character must be retired.");									    if (rogue_like_commands)										msg_print("Use 'Q' to when you are ready to retire.");									    else										msg_print("Use <Control>-K when you are ready to retire.");									} else {									    (void)strcpy(died_from, "(saved)");									    prt("Saving game...",0,0);									    i=pack_heavy;									    j=turn;									    if (save_char())												prt("done.",0,14);											else									    	prt("Save failed.",0,14);									    turn=j;									    pack_heavy=i;									    change_speed(pack_heavy);   /* fix up speed stuff that save_char modifies KHR */									    character_saved=0;									    									    move_cursor_relative(char_row,char_col);									    (void)strcpy(died_from, "(alive and well)");									}								}							break;						case 5: /* hide/show recall */							if (recall_hidden)								{									ShowWindow(recallw);									if (FrontWindow()==recallw)										HiliteControl(rscroll,0);									else										HiliteControl(rscroll,255);								}							else								HideWindow(recallw);							recall_hidden=1-recall_hidden;							break;						case 6: /* hide/show choices */							if (choices_hidden)								{									ShowWindow(choicesw);									if (FrontWindow()==choicesw)										HiliteControl(cscroll,0);									else										HiliteControl(cscroll,255);								}							else								HideWindow(choicesw);							choices_hidden=1-choices_hidden;							break;						case 8: /* save and quit */							if (game_in_progress && save_enabled)								{									if (total_winner) {									    msg_print("You are a Total Winner,  your character must be retired.");									    if (rogue_like_commands)										msg_print("Use 'Q' to when you are ready to retire.");									    else										msg_print("Use <Control>-K when you are ready to retire.");									} else {									    (void)strcpy(died_from, "(saved)");									    prt("Saving game...",0,0);									    if (save_char())									    	{													prt("done.",0,14);													MacExit();												}									    prt("Save failed.",0,14);									    move_cursor_relative(char_row,char_col);									    (void)strcpy(died_from, "(alive and well)");									}								}							else								MacExit();							break;						case 9: /* quit */							if (game_in_progress && save_enabled)								{									alert=(AlertTHndl)GetResource('ALRT',128);									center_rect(&(*alert)->boundsRect,&qd.screenBits.bounds);									item_hit=Alert(128,ynfilter);																		if(item_hit == 2)										{											MacExit();										}								}							else								MacExit();							break;											}				break;			case 130:  /* edit menu - nothing's enabled! */				break;			case 131:  /* font menu */				if (selection==1)					{						if (FrontWindow()==window)							{								angbandbold=1-angbandbold;								getsize_angband();																TextFace(angbandbold);								SizeWindow(window,WIDTH,HEIGHT,0);								InvalRect(&window->portRect);							}						if (FrontWindow()==recallw)							{								recallbold=1-recallbold;								getsize_recall();																SetPort(recallw);								TextFace(recallbold);								SetPort(window);																roff_recall(-1);  /* re-columnate recall stuff */							}						if (FrontWindow()==choicesw)							{								choicesbold=1-choicesbold;								getsize_choices();																SetPort(choicesw);								TextFace(choicesbold);								SetControlMaximum(cscroll, 22-(choicesw->portRect.bottom - choicesw->portRect.top-1)/CHOICES_FONT_HEIGHT);								DrawChoices();								SetPort(window);							}						break;					}				if (FrontWindow()==window)					{						GetItem(GetMHandle(131),selection,s);						GetFNum(s,&angbandfont);						if (!RealFont(angbandfont,angbandsize))  /* current size is bad for new font */							{								/* find good size */								for(i=1;i<=18;i++)									{										if (angbandsize-i>=9)											if (RealFont(angbandfont,angbandsize-i))												{													angbandsize-=i;													break;												}										if (angbandsize+i<=18)											if (RealFont(angbandfont,angbandsize+i))												{													angbandsize+=i;													break;												}									}								if (i==19) angbandsize==9;  /* default size if can't find a good size */							}						getsize_angband();												TextFont(angbandfont);						TextSize(angbandsize);						TextFace(angbandbold);						SizeWindow(window,WIDTH,HEIGHT,0);						InvalRect(&window->portRect);					}				if (FrontWindow()==recallw)					{						GetItem(GetMHandle(131),selection,s);						GetFNum(s,&recallfont);						if (!RealFont(recallfont,recallsize))  /* current size is bad for new font */							{								/* find good size */								for(i=1;i<=18;i++)									{										if (recallsize-i>=9)											if (RealFont(recallfont,recallsize-i))												{													recallsize-=i;													break;												}										if (recallsize+i<=18)											if (RealFont(recallfont,recallsize+i))												{													recallsize+=i;													break;												}									}								if (i==19) recallsize==9;  /* default size if can't find a good size */							}						getsize_recall();												SetPort(recallw);						TextFont(recallfont);						TextSize(recallsize);						TextFace(recallbold);						SetPort(window);												roff_recall(-1);  /* re-columnate recall stuff */					}				if (FrontWindow()==choicesw)					{						GetItem(GetMHandle(131),selection,s);						GetFNum(s,&choicesfont);						if (!RealFont(choicesfont,choicessize))  /* current size is bad for new font */							{								/* find good size */								for(i=1;i<=18;i++)									{										if (choicessize-i>=9)											if (RealFont(choicesfont,choicessize-i))												{													choicessize-=i;													break;												}										if (choicessize+i<=18)											if (RealFont(choicesfont,choicessize+i))												{													choicessize+=i;													break;												}									}								if (i==19) choicessize==9;  /* default size if can't find a good size */							}						getsize_choices();												SetPort(choicesw);						TextFont(choicesfont);						TextSize(choicessize);						TextFace(choicesbold);						SetControlMaximum(cscroll, 22-(choicesw->portRect.bottom - choicesw->portRect.top-1)/CHOICES_FONT_HEIGHT);						DrawChoices();						SetPort(window);					}				break;			case 132:  /* size menu */				if (FrontWindow()==window)					{						GetItem(GetMHandle(132),selection,s);						s[s[0]+1]=0;						angbandsize=atoi((char*)(s+1));						getsize_angband();												TextSize(angbandsize);						SizeWindow(window,WIDTH,HEIGHT,0);						InvalRect(&window->portRect);					}				if (FrontWindow()==recallw)					{						GetItem(GetMHandle(132),selection,s);						s[s[0]+1]=0;						recallsize=atoi((char*)(s+1));						getsize_recall();												SetPort(recallw);						TextSize(recallsize);						SetPort(window);												roff_recall(-1);  /* re-columnate recall stuff */					}				if (FrontWindow()==choicesw)					{						GetItem(GetMHandle(132),selection,s);						s[s[0]+1]=0;						choicessize=atoi((char*)(s+1));						getsize_choices();												SetPort(choicesw);						TextSize(choicessize);						SetControlMaximum(cscroll, 22-(choicesw->portRect.bottom - choicesw->portRect.top-1)/CHOICES_FONT_HEIGHT);						DrawChoices();						SetPort(window);					}				break;			case 133:   /* other menu */				switch (selection)					{						case 1:  /* yellow floor */							yellowfloor=1-yellowfloor;							setfloorcolor();							InvalRect(&window->portRect);							break;					}		}	HiliteMenu(0);}static pascal void scrollproc (ControlHandle c, short code){	int	pageSize;	int	amount;	int oldamt;		if (code == 0)		return;		oldamt = amount = GetCtlValue(c);		switch (code) {		case inUpButton: 			amount += -1;			break;		case inDownButton: 			amount += 1;			break;		case inPageUp: 			amount += -(recallw->portRect.bottom/RECALL_FONT_HEIGHT)+1;			break;		case inPageDown: 			amount += (recallw->portRect.bottom/RECALL_FONT_HEIGHT)-1;			break;	}	if (amount<0) amount=0;	if (amount>29) amount=29;	if (amount==oldamt)		return;	SetCtlValue(c, amount);	DrawRecall();}static pascal void scrollproc_choices (ControlHandle c, short code){	int	pageSize;	int	amount;	int oldamt;		if (code == 0)		return;		oldamt = amount = GetCtlValue(c);		switch (code) {		case inUpButton: 			amount += -1;			break;		case inDownButton: 			amount += 1;			break;		case inPageUp: 			amount += -(choicesw->portRect.bottom/CHOICES_FONT_HEIGHT)+1;			break;		case inPageDown: 			amount += (choicesw->portRect.bottom/CHOICES_FONT_HEIGHT)-1;			break;	}	if (amount<0) amount=0;	if (amount>GetControlMaximum(c)) amount=GetControlMaximum(c);	if (amount==oldamt)		return;	SetCtlValue(c, amount);	DrawChoices();}/* returns 0 if nothing happening, 1 if something happening */int events(){	EventRecord event;	WindowPtr w;	char ch;	Rect r,clipsave;	ControlHandle c;	int cntlcode;	long newsize;		SystemTask();	GetNextEvent(everyEvent,&event);		switch(event.what)		{			case nullEvent:				return(0);			case activateEvt:				w=(WindowPtr)event.message;				if (w==recallw)					{						SetPort(w);												if (event.modifiers&activeFlag)							{								HiliteControl(rscroll,0);							}						else							{								HiliteControl(rscroll,255);							}												r=w->portRect;						r.left=r.right-15;						ClipRect(&r);						DrawGrowIcon(recallw);						ClipRect(&w->portRect);						SetPort(window);					}				if (w==choicesw)					{						SetPort(w);												if (event.modifiers&activeFlag)							{								HiliteControl(cscroll,0);							}						else							{								HiliteControl(cscroll,255);							}												r=w->portRect;						r.left=r.right-15;						ClipRect(&r);						DrawGrowIcon(choicesw);						ClipRect(&w->portRect);						SetPort(window);					}				return(1);			case updateEvt:				w=(WindowPtr)event.message;				BeginUpdate(w);				SetPort(w);				/* refresh window */				if (w==window)					DrawScreen();				if (w==recallw)					{						DrawRecall();						SetPort(window);					}				if (w==choicesw)					{						DrawChoices();						SetPort(window);					}				EndUpdate(w);				return(1);			case keyDown:			case autoKey:				ch=event.message&charCodeMask;				if (event.modifiers&cmdKey)					{						setup_menus();						if (!save_enabled && (ch=='Q' || ch=='q'))							ch='e';						menu(MenuKey(ch));						HiliteMenu(0);						return(1);					}				ObscureCursor();				machitkey(ch);				return(1);			case mouseDown:				switch(FindWindow(event.where,&w))					{						case inMenuBar:							setup_menus();							menu(MenuSelect(event.where));							HiliteMenu(0);							return(1);						case inSysWindow:							SystemClick(&event,w);							return(1);						case inDrag:							r=screenBits.bounds;							r.top+=20;							InsetRect(&r,4,4);							DragWindow(w,event.where,&r);							return(1);						case inGoAway:							if (TrackGoAway(w,event.where))								{									if (w==recallw)										{											HideWindow(recallw);											recall_hidden=1-recall_hidden;										}									if (w==choicesw)										{											HideWindow(choicesw);											choices_hidden=1-choices_hidden;										}								}							return(1);						case inGrow:							if (w==recallw)								{									SetPort(w);									r.left=30*RECALL_FONT_WIDTH;									r.right=BIGVTYPESIZ*RECALL_FONT_WIDTH;									r.top=RECALL_FONT_HEIGHT;									r.bottom=30*RECALL_FONT_HEIGHT;									newsize=GrowWindow(w,event.where,&r);									if (!newsize)										{											SetPort(window);											return(1);										}									SizeWindow(w,LoWord(newsize),HiWord(newsize),1);									ClipRect(&w->portRect);																		/* move scroll bar to correct location */									r=w->portRect;									r.right++;									r.left=r.right-16;									r.top--;									r.bottom-=14;									(*rscroll)->contrlRect=r;																		EraseRect(&w->portRect);									DrawControls(recallw);									r=w->portRect;									r.left=r.right-15;									ClipRect(&r);									DrawGrowIcon(recallw);									ClipRect(&w->portRect);																		roff_recall(-1);  /* re-columnate recall stuff */																		SetPort(w);									ValidRect(&w->portRect);  /* we've drawn it all- no need to redraw */																		SetPort(window);									return(1);								}							if (w==choicesw)								{									SetPort(w);									r.left=30*CHOICES_FONT_WIDTH;									r.right=80*CHOICES_FONT_WIDTH+15+4;									r.top=CHOICES_FONT_HEIGHT;									r.bottom=22*CHOICES_FONT_HEIGHT+2;									newsize=GrowWindow(w,event.where,&r);									if (!newsize)										{											SetPort(window);											return(1);										}									SizeWindow(w,LoWord(newsize),HiWord(newsize),1);									ClipRect(&w->portRect);																		/* move scroll bar to correct location */									r=w->portRect;									r.right++;									r.left=r.right-16;									r.top--;									r.bottom-=14;									(*cscroll)->contrlRect=r;																		/* adjust scroll bar bounds */									SetControlMaximum(cscroll, 22-(w->portRect.bottom - w->portRect.top-1)/CHOICES_FONT_HEIGHT);																		EraseRect(&w->portRect);									DrawControls(choicesw);									r=w->portRect;									r.left=r.right-15;									ClipRect(&r);									DrawGrowIcon(choicesw);									ClipRect(&w->portRect);																		SetPort(w);									DrawChoices();									ValidRect(&w->portRect);  /* we've drawn it all- no need to redraw */																		SetPort(window);									return(1);								}						case inContent:							if (w==window)								{									SelectWindow(w);									return(1);								}							if (w==recallw)								{									SetPort(w);									GlobalToLocal(&event.where);									cntlcode=FindControl(event.where, w, &c);									if (cntlcode==0)										{											SelectWindow(w);										}									else if (cntlcode==inThumb)										{											TrackControl(c, event.where, 0L);											DrawRecall();										}									else										{											TrackControl(c, event.where, ((void *) scrollproc));										}									SetPort(window);									return(1);								}							if (w==choicesw)								{									SetPort(w);									GlobalToLocal(&event.where);									cntlcode=FindControl(event.where, w, &c);									if (cntlcode==0)										{											SelectWindow(w);										}									else if (cntlcode==inThumb)										{											TrackControl(c, event.where, 0L);											DrawChoices();										}									else										{											TrackControl(c, event.where, ((void *) scrollproc_choices));										}									SetPort(window);									return(1);								}					}				return(1);		}}static void check_for_save_file(){	short message,n;	AppFile fileinfo;	OSErr err;	short vrefnum;	long drefnum,junk;	CountAppFiles(&message,&n);	if (message!=appOpen)		n=0;	if (n>0) n=1;		/* can only open 1 save file at a time */		if (n==1)		{			GetAppFiles(1,&fileinfo);			if (fileinfo.fType != 'SAVE')  /* user clicked on help file or something: ignore */				return;			err=GetWDInfo(fileinfo.vRefNum,&vrefnum,&drefnum,&junk);						if (err==noErr)				{					savefile=refnum_to_name(drefnum,vrefnum,(char*)fileinfo.fName);										game_in_progress=1;					disable_start();										pause_line(23);  /* deferred from read_times */										unix_main(FALSE);				}			else				{					mac_warning("Could not open save file");				}		}}int rgbcolor;main(){	long response;		SetApplLimit(GetApplLimit()-100000L);  /* ~100K of extra stack */	MaxApplZone();	InitGraf(&thePort);	InitFonts();	InitWindows();	InitMenus();	InitDialogs(0);	InitCursor();		Gestalt(gestaltQuickdrawVersion,&response);	response = response & 0xFFFFL;  /* take low-order word */	if (response>=gestalt32BitQD13)		rgbcolor=2; /* use RGBForeColor... */	else if (response==gestalt8BitQD || response==gestalt32BitQD ||					 response==gestalt32BitQD11 || response==gestalt32BitQD12)		rgbcolor=1; /* use PmForeColor... */	else		rgbcolor=0; /* no color at all */		_fcreator='A258';	_ftype='SAVE';		init_window();	init_menu();	InitScreen();		disable_save();	  init_mac_arrays();		read_times();	ValidRect(&window->portRect);		check_for_save_file();		while(1)		events();	}