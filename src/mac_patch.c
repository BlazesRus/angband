#include <MacHeaders>#include <ctype.h>#include <string.h>#include "angband.h"#include "mac-io.h"#include <unix.h>describe_mon_type *desc_list;treasure_type *object_list;int _new_log(){	return(1);}/*int geteuid(){	return(1);}*//*int setuid(int x){	return(0);}*//*int getuid(){	return(0);}*//*int gethostname(char *c,int len){	c[0]='M';	c[1]='a';	c[2]='c';	c[3]=0;	return(0);}*//*void init_files(){}*//*int user_name(char *c,int len){	c[0]='B';	c[1]='o';	c[2]='b';	c[3]=0;	return(0);}*/int chmod(char *fnam,int mode){	return(0);}int access(char *name,int n){	return(1);}/*void bzero(char *str,int len){	int i;	for(i=0;i<len;i++)		str[i]=0;}*//*int16 *exit_flag;*/void link(char *f1,char *f2){	rename(f1,f2);}/*void unlink(char *f){	remove(f);}*/void delay(int x){	long t;		t=TickCount();	while(TickCount()<t+(x*60)/1000);}/* delay x microseconds *//*void usleep(long x){	long sixtieths;	long t;		/ there's a better way to do this, but I need more Inside Mac volumes... /	sixtieths = x/16667;		t=TickCount();	while(TickCount()<t+sixtieths);}*//*int fchmod(char *fnam,int mode){	return(0);}*//*int getpid(){	return(1);}*//*void kill(int pid,int x){}*/int suspend(){}void enablefilemenu(int x){}/*static char *color_names[18]={"white      ","yellow     ","orange     ","red        ","pink       ","purple     ",	"blue       ","lightblue  ","lightgreen ","green      ","brown      ","lightbrown ","lightgray  ",	"gray       ","darkgray   ","black      ","multihued  ","floorcolor "};*/void init_mac_arrays(){	long i;	char *cavedata;	/*	int flag;	FILE *f;	char c;	*/		/*  fill desc_list */	desc_list = malloc(MAX_CREATURES*sizeof(describe_mon_type));	for(i=0;i<332;i++)		desc_list[i]=desc_list1[i];	for(i=332;i<332+217;i++)		desc_list[i]=desc_list2[i-332];		/* allocate cave array */		cavedata=calloc(((long)MAX_HEIGHT)*MAX_WIDTH*sizeof(cave_type),1);	/* bzero((char*)cavedata,((long)MAX_HEIGHT)*MAX_WIDTH*sizeof(cave_type)); */	for(i=0;i<MAX_HEIGHT;i++)		cave[i]=(cave_type*)(cavedata+(i*MAX_WIDTH)*sizeof(cave_type));			/* fill object_list */	object_list=malloc(MAX_OBJECTS*sizeof(treasure_type));	for(i=0;i<204;i++)		object_list[i]=object_list1[i];	for(i=204;i<204+309;i++)		object_list[i]=object_list2[i-204];		/* checking color assignments */#if 0	{		FILE *f;		char c;		int flag;		f=fopen("junk","w");		/*		for(c=' ';c<127;c++)		*/			{				flag=0;				for(i=0;i<MAX_CREATURES;i++)				/*					if (c==c_list[i].cchar)						{						fprintf(f,"%c %3d %s %s\n",c,c_list[i].level,color_names[c_list[i].color],c_list[i].name);						flag=1;						}				*/					{						fprintf(f,"%s\n  %s\n    %s\n\n",c_list[i].name,color_names[c_list[i].color],								desc_list[i].desc);					}				/*				if (flag) fprintf(f,"\n");				*/			}		fclose(f);	}#endif}/*int stricmp(char *s1, char *s2){	char c1,c2;		while((c1=*s1) && (c2=*s2))		{			c1=tolower(c1);			c2=tolower(c2);						if (c1<c2)				return(-1);			if (c1>c2)				return(1);			s1++;			s2++;		}	if (*s2)		return(-1);	if (*s1)		return(1);	return(0);}*/void initsavedefaults(){	char *c;		c=savefile+strlen(savefile);	while((*c != ':') && (c >= savefile)) c--;	c++;	sprintf(c,"%s",py.misc.name);}#if 0unsigned long *current_state;char *initstate(seed, arg_state, n)    unsigned long               seed;	   /* seed for R. N. G. */    char               *arg_state; /* pointer to state array */    int                 n;	   /* # bytes of state info */{	char *ostate;		ostate=(char *)current_state;	current_state=(unsigned long *)arg_state;	current_state[0]=seed;}char *setstate(arg_state)    char               *arg_state;{    unsigned long      *new_state = (unsigned long *)arg_state;    char               *ostate = (char *)current_state;        current_state=new_state;    return(ostate);}void srandom(x)    unsigned long        x;{	current_state[0]=x;}unsigned long random(){	unsigned long x;		x=randSeed=current_state[0];	Random();	current_state[0]=randSeed;	return(x);}#endifFILE *my_tfopen(const char *x, const char *y){	return(fopen(x,y));}int my_topen(const char *x, int y, int z){	return(open((char*)x,y));}int kbhit(){	return(check_input(0));}int getch(){	char c;	macgetkey(&c);	return(c);}void c_print(int16u ch, int row, int col){    row -= panel_row_prt;	   /* Real co-ords convert to screen				    * positions */    col -= panel_col_prt;	DSetScreenCursor(col, row);	CWriteScreenChar(ch);}void c_prt(int8u color, const char *str_buff, int row, int col){    Rect                line;    int16u				text[BIGVTYPESIZ];    int					i;    if (row == MSG_LINE && msg_flag)	msg_print(NULL);	    line.left = col;    line.top = row;    line.right = SCRN_COLS;    line.bottom = row + 1;    DEraseScreen(&line);		for(i=0;str_buff[i];i++)		{			text[i]=CC(color,str_buff[i]);		}	text[i]=0;	    c_put_buffer(text, row, col);}void c_put_buffer(out_str, row, col)    int16u        *out_str;    int                 row, col;{	DSetScreenCursor(col, row);	CWriteScreenString(out_str);}void c_put_buffer2(int8u color, const char *out_str, int row, int col)/*	int8u				color;    const char         *out_str;    int                 row, col;    */{	int16u text[VTYPESIZ];	int i;		for(i=0;out_str[i];i++)		text[i]=CC(color,out_str[i]);	text[i]=0;	c_put_buffer(text,row,col);}